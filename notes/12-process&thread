프로세스와 스레드.
1. 프로세스 개요
프로세스는 보조기억장치에 저장되어 있는 프로그램을 메모리에 적재하고 실행되는 순간 그 프로그램을 프로세스라고 말한다.
이때, 사용자가 볼수 있는 곳에서 실행되는 프로세스는 포그라운드 프로세스, 볼수 없다면 백그라운드 프로세스 라고 한다.
백그라운드 프로세스 중에서도, 사용자와 상호작용 할수 있는 프로세스가 있는 반면, 상호작용하지 않는 프로세스도 있는데, 이를 유닉스 운영체제에서는 ‘데몬’, 윈도우에서는 ‘서비스’ 라고 부른다.

- 프로세스 제어블록 PCB
모든 프로세스는 CPU를 필요로 하지만 CPU 자원은 한정적이다. 즉, 프로세스들은 계속 번갈아 가면서 한정된 시간만큼만 CPU를 이용하게 된다.
이때의 시간이 끝낫음을 알리는 인터럽트 (타이머 인터럽트) 가 있다.

아무튼 운영체제는 빠르게 번갈아 수행되는 프로세스의 실행순서를 관리하고 프로세스 각각에 자원을 분배 해야 하는데, 이를 위해서 PCB(프로세스 제어블록) 을 사용한다.
PCB는 마치 이거와 같다. 프로세스들에 대하여, 구분을 하기 위하여, 대표적인 정보, 마치 옷을 분류하기 위하여 태그가 붙여있는 것 마냥 있는 것으로 생각해도 된다.
PCB는 커널 영역에 생성되며, 운영체제는 많은 프로세스들 사이에서 PCB으로 특정 프로세스를 식별하고 해당 프로세스를 처리하는 데 필요한 것을 판단한다.
새로운 프로세스가 생성되었다면, 운영체제가 PCB를 생성하며, 프로세스가 종료되면, 해당 프로세스의 PCB도 폐기 된다.

PCB에는 이러한 정보들이 있다.
1) 프로세스 ID (PID)
식별을 위한 고유 번호이다. 물론, 같은 일을 하는 프로그램이더라도, 다른 PID가 부여된다.
2) 레지스터 값
프로세스들은 CPU를 비롯한 자원들을 번갈아가며 쓰게 된다. 즉 자신의 차례가 끝나고, 다시 자신의 차례가 돌아왔다면, 이전에 사용했었던, 레지스터들의 중간값들을 모두 복원하기 위해서 PCB에는 레지스터 값들이 담겨져 있다.
3) CPU 스케줄링 정보
프로세스가 언제 어떤 순서로 CPU를 할당 받을지에 대한 정보도 담긴다.
4) 메모리 관리 정보
프로세스마다 메모리에 저장한 위치가 다르다. 그래서 PCB에는 프로세스가 어느 주소에 저장되어 있는지에 대한 정보가 필요하다.
즉, 베이스 레지스터, 한계 레지스터, 페이지 테이블 정보 등도 담긴다.
5) 사용한 파일과 입출력장치 목록
프로세스가 실행과정에서 특정 입출력 장치나, 파일을 사용하면, 그 내용이 명시된다.


- 문맥 교환
하나의 프로세스에서 타이머 인터럽트가 발생하고 다음 프로세스로 실행순서가 넘어갈때, 문맥교환이 일어난다.
우선 문맥은 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보로, 위의 PCB가 저장한 정보가 이에 속한다.
이런식으로 교환이 일어난다. 프로세스 A가 실행중이다. 이후 실행이 마칠 무렵 프로세스 A의 문맥을 PCB에 저장한다. 
이후 다음으로 실행할 프로세스 B의 PCB로 부터 문맥을 가져오고.  B가 실행된다.

- 프로세스의 메모리 영역
프로세스가 생성되면 커널영역에는 PCB가 생성된다.
반면 사용자영역에는 프로세스가 이렇게 배치된다. ‘코드 영역, 데이터 영역, 힙 영역, 스택 영역’
하나씩 봐보자.
1) 코드영역
실행할 수 있는 코드, 기계어로 이루어진 명령어가 저장된다. 그러나, 데이터가 아닌, CPU가 실행할 명령어가 담겨있기 때문에 쓰기가 금지 되어있다.
읽기 전용 공간이다.,
2) 데이터영역
잠깐 썻다가 없앨 데이터가 아닌, 프로그램이 실행되는 동안 유지할 데이터가 저장되는 공간이다.
대표적으로는 전역변수가 그 예시이다.
코드영역과 데이터영역 모두 크키가 변하지 않으며, 고정된 정적 할당 영역이다. 
3) 힙 영역
프로그래머가 직접 할당할 수 있는 저장 공간이다. 
만약 힙 영역에 메모리 공간을 할당 했다면 해당 공간을 반환해야 한다. 메모리 누수와 같은 문제가 있기 때문이다.
4) 스택영역
데이터를 일시적으로 저장하는 공간이다. 데이터 영역과 달리, 잠깐 쓰다가, 이후 안쓰는 값들이 저장되는 공간이라 봐도 된다.
예를 들어, 함수의 실행이 끝나면 사라지는 매개 변수, 지역변수가 대표적이다.

힙영역과 스택영역은 그 크기가 계속 변하기에 동적 할당 영역이라 부른다. 또한, 메모리에서 동적 할당 영역에 있어서. 힙과 스택 영역이 겹치지 않도록,
힙 영역은 메모리의 낮은 주소에서 높은 주소 순으로, 스택영역은 높은 주소에서 낮은 주소 순으로 할당된다.


2. 프로세스 상태와 계층 구조
- 프로세스 상태
1) 생성상태: 프로세스를 생성 중인 상태이다. 이제 막 메모리에 적재되어 PCB를 할당받은 상태로 봐도 된다. 
2) 준비상태: 언제든지  CPU를 할당받아 실행할 수 있으나, 아직 자신의 차례가 아니기에 기다리고 있는 상태이다.
대게 준비상태인 프로세스가 실행상태로 전환되는 것을 ‘디스패치’ 라고 한다.

3) 실행상태: 이 상태의 프로세스는 CPU를 할당받아 실행중이다.
이후, 시간을 모두 사용하여 타이머 인터럽트가 발생하면, 다시 준비 상태가 되어 기다린다.
4) 대기상태: 실행상태 도중에, 프로세스가 입출력장치를 사용하게 되는 경우이다. 만약 이럴 경우, 입출력 장치는 처리 속도가 매우 느리기에, 입출력장치가 완료 인터럽트를 받을때까지 기다려야 한다.
이 기다리는 상태를 대기 상태로 하며, 입출력장칙 완료되었다면, 대기상태를 풀고, 준비상태로 다시 전환되며, 차례를 기다린다.
5) 종료상태: 프로세스가 종료된 상태로, 운영체제가 PCB와 프로세스가 사용한 메모리를 정리하게 된다.

프로세스들은 저 상태들을 계속 순회하며, 생성상태부터 종료상태까지 계속 상태가 변하게 된다.
이를 프로세스 상태 다이어그램이라고도 한다.

- 프로세스 계층 구조
프로세스는 실행상태인 도중에, 다른 프로세스를 생성할 수 있다. 이때 새 프로세스를 생성한 프로세스를 부모 프로세스, 생성된 프로세스를 자식 프로세스라고 한다.
두 프로세스는 각기 다른 PID를 지니면서, 자식 프로세스는 부모 프로세스의 PID인 PPID가 기록되기도 한다.
이렇게 프로세스가 프로세스를 낳고 계속 이를 반복하는 계층적인 구조로써 보며, 운영체제가 프로세스들을 관리한다.
이 구조를  프로세스 계층 구조라고 한다.
예를 들어보자. 컴퓨터를 키고, 로그인하여, 이후에는 인터넷 브라우저를 실행했다고 치자.
최초의 프로세스 -> 로그인 프로세스 -> 인터넷 브라우저 프로세스
이런식으로 부모 자식 계층 구조 프로세스가 나타났다고 봐도 된다.

(최초의 프로세스는 PID가 항상 1번이며, 유닉스는 init, 리눅스는 systemd, mac은 launchd 이다)

그러면 어떻게 부모가 자식 프로세스를 생성하는 것일까..? 
이렇게 보면 된다. fork으로 부모가 자기 자신을 복제한다. 이후 복제품(자식 프로세스)을 exec을 통해 자식 자기 자신이 메모리 공간을 다른 프로그램으로 교체한다.
이로 인하여, 부모 프로세스의 자원들과, 메모리 내용, 열린 파일의 목록등이 자식 프로세스에 상속되는 상속성 특징도 갖게 된다. (물론 PID는 다르다)


------------------------------------------------------------------------------------------------------------------------------------------------------------

이제 코드와 같이 봐보자. 이 코드를 봐보자.
#include <stdio.h>
#include <unistd.h>  //윈도우 환경에서는 안된다.

int main() {
	printf("parent pid is %d\n", getpid());
    fflush(stdout);
    
	if (fork() == 0) {
		printf("child pid is %d\n", getpid());

	}

	return 0;
}
우선 PID는 운영체제가 그때그때 부여하는 값이기 때문에, 실행마다, PID값은 달라지게 된다.
코드를 봐보자. printf("parent pid is %d\n", getpid()); 을 실행하여, 커널에게 요청하여 자신의 PID 를 반환하게 하였다.
이후에 printf를 통해 stdout 버퍼에 문자열이 저장된 상태이다.

fflush(stdout); 를 보자. 이것을 쓴 이유는 printf을 통해 버퍼링이 되었기 때문이다. 다시 생각해보자. fork()는 메모리를 전체를 복제하는 것이다.
즉 이후 출력에 있어서, fflush(stdout); 으로 버퍼를 비우지 않는다면, fork()를 한 자식 프로세스에 대해서 부모 PID또한 출력이 되게 된다.

이제 제대로 봐보자. fork()을 호출하여, 복제하여 자식 프로세스를 생성하였다.
CPU는 사용자 모드에서 커널모드로 전환되었다. 이후 운영체제는 프로세스를 복사한다. 이를 통하여, '상속성' 이 유지 된 상황이지만.
PID와 저장된 메모리 주소는 엄연히 다르게된다.
(이때 fork()는 부모가 호출한 것이다. 그렇게 커널모드로 들어가거니와, 복제되어, 자식 프로세스가 새로 생성된다. 그리고 딱 한번의 fork 호출 결과를 
커널이 부모에게는 자식의 PID를, 자식프로세스에게는 0을 반환한다.)

즉 fork() == 0 은 조건문에 의하여, 부모 프로세스가 아닌, 자식 프로세스만 함수안으로 들어오게 되는 것이다.

이후 코드는
parent pid is 238
child pid is 239 이렇게 결과로 나오게 된다. 

위의 설명에 대하여 fork()만 다시 제대로 볼 수 있을 코드를 하나더 봐보자.
#include <stdio.h>
#include <unistd.h> 
int main()
{
  printf("parent pid is %d\n", getpid());

  if (fork() == 0) {
    printf("child pid is %d\n", getpid());
  }
  printf("executed!\n");
  return 0;
}

이때의 실행결과는 
parent pid is 53796
executed!
child pid is 53797
executed!    으로 printf("executed!\n"); 가 2번 실행되게 된다. 왜 그럴까? 다시 봐보자.

fork()에 의하여 부모 프로세스는 복제하여 자식 프로세스를 생성하였다. 즉 fork()==0 은 자식 프로세스에 대해서만 고르는 조건문일뿐
이후에는 실행흐름이 코드내에서 2개가 되어, if 바깥의 printf("executed!\n"); 코드는 부모, 자식 프로세스 모두 실행되게 된다.
즉 실행 주체가 2개가 되는 것이다. 한 코드를 공유하는 것이 아닌, 각자 실행하게 되어 여러번 printf문이 실행되는 것이다.

//이때 실행결과의 순서는 일단 중요치 않다. 다를 수 있으며, 오로지 중요한 것은 executed 가 2번 나온것이다.

이제 다른 연계 코드들도 봐보자.
///////////////////
#include <stdio.h>
#include <unistd.h>  

void foo(){
    printf("excute foo\n");
}

int main() {
	if (fork() == 0){
        if (fork() == 0){ //자식 프로세스가 또 자식 프로세스를 생성시킴
            //임의로 자손 프로세스라고 말하자면, 자손 프로세스만 printf문 실행됨
            printf("child of child pid is %d\n", getpid());
            
        }
        else{ //이는 자식 프로세스
            printf("child pid is %d\n", getpid());
            foo();
        }
    }
    else{
        if(fork() == 0){
            //부모 프로세스에서 또 자식 프로세스가 생성됨. 결과적으로는 부모 프로세스에 2개의 자식이 생성됨
            printf("child pid is %d\n", getpid());
            foo();
        }
        else{
            //부모 프로세스
            printf("parent pid is %d\n", getpid());
            foo();
        }
    }

    return 0;
}


////////////////////////////////////////////////

3. 스레드
스레드는 프로세스를 구성하는 실행의 흐름 단위이다. 즉 한 프로세스는 여러개의 스레드로 동시에 실행 할 수 있다. ‘프로세스를 구성하는 실행단위’ 라고 봐도 된다.
만약 한 프로세스에 하나의 스레드만을 가지는 것을 단일 스레드 프로세스 라고 한다.

스레드는 프로세스 내에서 각기 다른 스레드 ID, 프로그램 카운터 값을 비롯한 레지스터 값, 스택으로 구성되어있다.
하지만 중요한 것은 각각 위에 언급한 정보만을 유지하고, ‘프로세스 자원은 공유’ 한다는 것이다.

즉 이 말은 스레드마다, 코드/데이터.힙 영역이 있는게 아니라는 것이다.

이에 따라서 이런 것이 설명이 가능하다. 동일한 작업을 수행하는 단일 스레드 프로세스 3개를 실행하는 것과, 하나의 프로세스를 3개의 스레드로 실행하는 것이 무엇이 다를까?
간단하다. 프로세스끼리는 자원을 공유하지 않기에, 메모리를 각 프로세스가 차지하게 되는 문제점이 있다.
반면에 스레드들은 프로세스가 가지고 있는 자원을 공유하기에, 메모리를 더 효율적으로 사용할 수 있게 된다. 
물론 이것에도 이런 문제점이 있다. 만약 멀티프로세스 환경에서 하나의 프로세스가 오류 및 문제를 일으키게 된다면, 별로 지장이 없을것이다.  다른 프로세스가 있으니까 말이다.
하지만 멀티스레드 환경에서는 하나의 스레드에 문제가 생긴다면, 그 다른 스레드들도 마찬가지거니와, 한 프로세스 전체에 문제가 생긴다. 왜냐하면 말 그대로 프로세스가 가지고 있는 것을 ‘공유’하기 때문이다. 

+) 프로세스 간 통신 IPC
위에서 서술했든 프로세스는 기본적으로 자원을 공유하지는 않지만, 예외가 있다.
예를 들어, 프로세스 A는 “hello.txt” 파일에 새로운 값을 쓰는 프로세스인 반면, 프로세스 B는 “hello.txt” 파일을 읽는 프로세스 이다. 즉 “hello.txt” 파일 속 데이터를 불가피하게 주고 받게 된다.
이를 파일을 통한 프로세스 간 통신으로 볼 수 있다.
또한 프로세스들 끼리는 메모리 영역에서 다 연속적으로 적재 되는 것이 아니다. 각 프로세스 사이에는 다른 메모리 영역이 있는데,
이 영역이 ‘공유 메모리’ 이다. 

-----------------------------------------------------------------------
스레드 관련 코드를 봐보자. 
#include <stdio.h>
#include <unistd.h>

int main()
{
    printf("process id is %d", getpid());
    return 0;
} 우선 이 코드는 위에서 봤다시피, 같은 코드이다. 실행하게 되면 제대로 출력이고, PID가 출력되며, 새로운 프로세스가 생성된다.

그럼 프로세스에 새로운 스레드를 만드는 코드를 보자.
#include <stdio.h>
#include <unistd.h>
#include <pthread.h> //리눅스 / 유닉스 계열에서 쓰는 표준 스레드 라이브러리

void* foo(){ //일부로 void* 으로 한다. 어떤 타입의 인자도 받아야 하기에.
    printf("process id is %d\n", getpid());
    return NULL;
}

int main()
{
    pthread_t thread1; // 스레드의 ID를 담는 자료형이다. 마치 프로세스의 PID와 비슷하게 봐도 된다.
    pthread_create(&thread1, NULL, foo, NULL); //스레드 생성. thread1은 foo를 실행토록 스레드를 생성하게 한다.
    //인자에 맞춰서 의미는 이거다. (생성된 스래드 ID를 어디에 저장할지, 스레드 속성, 이 스레드가 실행할 함수, 함수에 전달한 인자)
    pthread_join(thread1, NULL); //thread1 을 실행시키는 함수. foo가 끝날 때까지 대기한다.
    
    return 0;
}
기억하자 스레드가 하나 생성되는 것은 프로세스를 하나 새로 만드는것과는 완전히 다르다.

스레드의 고유한 식별자를 확인하는 방법에는 여러가지 있지만 pthread_self()를 이용해보자.

void* foo(){
    long thread_id = (long int)pthread_self(); //현재 실행중인 스레드의 id가 저장됨.
    printf("process id is %d\n", getpid()); //프로세스 id PID. 다른 스레드라도 출력이 같다. (꼭 기억하자. 스레드는 PID와 같은 프로세스 자원을 공유한다)
    printf("Thid is thread %ld\n", thread_id); //foo 스레드. 이는 각 스레드의 최소 정보인 스레드 id가 출력되는 거다.
    //스레드마다 스레드 ID, PC비롯 레지스터, 스택은 따로 가짐도 기억하자.
    return NULL;
}

int main() 
{
    pthread_t thread1;
    pthread_create(&thread1, NULL, foo, NULL);
    //커널이 새 스레드를 하나 생성하고, 새 스레드의 시작 함수는 foo가 됨. 그리고 새 스레드의 ID가 thread1 에 저장됨.
    pthread_join(thread1, NULL);
    
    return 0;
}


연계 코드를 보자. 스레드를 여러개 생성되어지고, 각 스레드가 제각기 다른 작업을 한다.
#include <stdio.h>
#include <unistd.h>
#include <pthread.h>
void * foo() {
    printf("foo executed\n");
    return NULL;
}

void * bar() {
    printf("bar executed\n");
    return NULL;
 }

void * baz() {
    printf("baz executed\n");
    return NULL;
}

int main()
{
    pthread_t thread1;
    pthread_t thread2;
    pthread_t thread3;

    pthread_create(&thread1, NULL, foo, NULL);
    pthread_create(&thread2, NULL, bar, NULL);
    pthread_create(&thread3, NULL, baz, NULL);

    pthread_join(thread1, NULL);
    pthread_join(thread2, NULL);
    pthread_join(thread3, NULL);

    return 0;
 }
