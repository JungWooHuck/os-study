입출력 장치
1. 장치 컨트롤러와 장치 드라이버

1) 장치 컨트롤러.
일반적으로 CPU와 메모리의 데이터 전송률은 매우 높지만 (데이터를 교환하는 속도) 입출력장치의 데이터 전송률은 상대적으로 매우 낮다.
그렇기에 기본적으로 입출력장치와 CPU간의 통신은 매우 어려워 진다.
이 이유에 의하여, 입출력 장치는 컴퓨터에 직접 연결되는 것이 아닌, 장치 컨트롤러 라는 하드웨어를 통해 연결된다.
즉 입출력 장치는 장치 컨트롤러를 통하여 컴퓨터 내부와 정보를 주고받는다. 

장치 컨트롤러는 크게 3가지 기능이 있다. CPU와 입출력장치 간의 통신 중개, 오류 검출, 데이터 버퍼링 이다.
데이터 버퍼링에서 버퍼링은 전송률이 높은 장치와 낮은 장치 사이에 주고 받는 데이터를 버퍼라는 임시 공간에 저장하여 전송률을 비슷하게 맞추는 방법이다.
예를 들어 보자. CPU가 입출력 장치에 정보를 보낼때는 버퍼는 이 정보를 모았다가, 장치가 전송률이 낮은 것을 알기에 조금씩 정보를 일부로 내보낸다.
반대로 입출력 장치에서 CPU에 정보를 보낼때는 CPU가 전송률이 높은 것을 알기에, 버퍼에 모았다가 한번에 CPU에 전달한다.

이번엔 장치 컨트롤러의 간략한 내부 구조를 보자.
제일 중요한것은 이 안에 데이터 레지스터, 상태레지스터, 제어 레지스터 이렇게 3가지가 있다는 것이다.
각각 데이터 레지스터는 CPU와 입출력 장치 사이에 주고받을 데이터가 담기는 레지스터이며, 이 레지스터가 버퍼 역할을 한다. 최근에는 주고받는 데이터가 많다면 레지스터 대신 RAM을 사용하기도 한다.
상태 레지스터는 입출력 장치의 준비, 작업 완료 상태, 오류 등의 정보가 저장되고, 제어 레지스터는 입출력장치가 수행할 내용에 대한 제어 정보와 명령을 저장하낟.
이 레지스터들에 대한 데이터는 버스를 타고 CPU, 입출력장치에 전달된다.

2) 장치 드라이버
새로 장치를 컴퓨터에 연결 할때 설치 해야 하는 것으로,
장치 컨트롤러의 동작을 감지고, 제어함으로써, 장치 컨트롤러가 컴퓨터 내부와 정보를 주고받을 수 있게 하는 프로그램이다.
이는 마찬가지로 프로그램이므로 메모리에 저장된다.
즉 장치 컨트롤러가 입출력장치에 대하여, 인지할 수 있고, 동작시키는 정보에 대해 알 수 있게 하는 것이다.

장치 컨트롤러가 입출력 장치를 연결하기 위한 하드웨어적 통로라면, 장치 드라이버는 소프트웨어적 통로라고 생각하면 된다.

2. 입출력 방법
입출력 작업을 수행하려면 CPU와 장치컨트롤러가 정보를 당연히 주고 받아야 한다. 그럼 어떤 방법으로..? 
이떄 방법은 3가지가 있다.
1) 프로그램 입출력
기본적으로 프로그램 속 명령어로 입출력 장치를 제어하는 방법이다.
CPU가 프로그램 속 명령어를 실행하는 과정에서 입출력 명령어를 만나면, CPU는 입출력 장치에 연결된 장치 컨트롤러와 상호작용하며 입출력 작업을 수행한다.
메모리에 저장된 정보를 하드 디스크에 백업하는 상황을 가정해보자 (대게 보조기억 장치도 입출력 장치로 묶여서 설명하곤 한다)
- 우선 메모리에 저장된 정보를 디스크에 백업한다는 것은 다른 말로는 하드 디스키에 새로운 정보를 쓴다는 것이다. CPU 는 하드 디스크 컨트롤러의 ‘제어 레지스터’ 에 쓰기 명령을 보낸다
- 이후 하드 디스크 컨트롤러는 하드 디스크의 상태를 확인하고, 상태 레지스터에 준비가 됬음을 표시한다.
- CPU는 상태 레지스터를 주기적으로 읽어보며 준비 여부를 확인한다. 이후 CPU 가 하드 디스크가 준비됨을알게 된 순간, 백업할 메모리의 정보를 데이터 레지스터에 쓴다. 
만약 백업 작업이 전부다 되지 않았다면,  다시 처음부터 반복한다. 


이렇게 프로그램 입출력 방식에서의 입출력 방식은 CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀으로써 이루어 진다.
하지만 방법에 나와있듯 'CPU는 주기적으로 계속 레지스터를 읽어봐야 한다.' 이를 폴링이라고 하며, 이 방식은 즉 CPU 낭비가 있다.
그럼 CPU는 어떻게 이 레지스터들을 아는 것일까?
(1) 메모리 맵 입출력
메모리에 접근하기 위한 주소 공간과, 입출력 장치에 접근하기 위한 주소공간을 하나의 주소 공간으로 간주하는 방법이다.
예를 들어 1024개의 주소를 표현할 수 있는 컴퓨터가 있을때, 모두 메모리 주소를 표현하는데 사용하지 않는다.
512개는 메모리 주소로, 512개는 장치 컨트롤러의 레지스터를 표현하기 위하여 사용하는 것이다.
이는 메모리에 접근하는 명령어와 다를바가 없는 같은 방법이다.
(2) 고립형 입출력
메모리를 위한 주소 공간과 입출력장치를 위한 주소 공간을 분리하는 방법이다.
예를 들어보자 아까처럼 1024개의 주소 공간을 가진 컴퓨터가 있는거다. 
이 상황에서 제어버스에 ‘메모리 읽기/쓰기’ 선 이 아닌, ‘입출력장치 읽기/ 쓰기’ 선이 또 따로 있다고 하는 것이다. 
만약 이렇다면 메모리 맵 입출력과는 다르게, 1024개의 주소 공간을 입출력장치든 메모리든 모두 활용할 수 있다.
(의문점: 메모리 맵 입출력과 비교하였을떄, 그럼 단점은 무엇인가..?)
//답: CPU의 구조가 복잡해진다. 또한 메모리 접근용 명령어와 I/O 접근용 명령어에 대해 따로따로 다르게 생각해야 하고 명령어 집합이 늘어난다. 


2) 인터럽트 기반 입출력
CPU가 입출력장치에 처리할 내용을 입력하면 입출력장치가 명령어를 수행하느 동안 CPU는 다른 일을 할수 있다.
또한 입출력장치가 CPU에게 인터럽트 요청신호를 보내면 CPU는 하던일을 멈추고, 백ㅇ럽한뒤, 해당 인터럽트를 처리하는 프로그램인 인터럽트 서비스 루틴을 실행한뒤 되돌아 온다고 하였었다.

이제 봐보자. 입출력장치에 의한 하드웨어 인터럽트는 더 정확히 말하자면, 입출력장치가 아닌, 장치 컨트롤러에 의해 발생한다.
CPU는 장치 컨트롤러에 입출력 작업을 명령하고, 장치 컨트롤러가 입출력 장치를 제어하며 입출력을 수행하는 동안 CPU는 다른 일을 할 수 있는 것이다.

이후 입출력 작업이 끝났다면 CPU에게 인터럽트 요청신호를 보내면 CPU는 하던일을 백업하고, 인터럽트 서비스 루틴을 실행하는 것이다.

그럼 많은 입출력 장치에서 인터럽트가 동시에 발생한 경우에 대해서를 봐보자.

간단하게는 우선 이런 방법이 있다. 인터럽트가 발생한 순서대로 인터럽트를 처리하는 것이다.
인터럽트 A를 처리하는 도중이였다면, 그 사이 B가 오더라도 우선 요청을 받아들이지 않는 것이며, A가 끝날때, B 의 인터럽트 서비스 루틴을 실행하는 것이다.
CPU가 플래그 레지스터 속 인터럽트 비트를 비활성한 채 인터럽트를 처리하는 경우, 다른 입출력 장치에 의한 하드웨어 인터럽트를 받아들이지 않기 때문에, 순차적으로 CPU는 이렇듯 하드웨어 인터럽트를 처리하게 된다, 

하지만 현실적으로는 불가능하다. 예컨대 인터럽트 중에서도 우선순위를 고려해야 하는 경우가 대부분 이기 때문이다.
즉, CPU가 A를 처리하다가, 우선순위가 높은 인터럽트 B가 요청을 한다면, A를 우선 멈추고 B를 먼저 처리하는 것이다.

플래그 레지스터 속 인터럽트 비트가 활성화 되어 있는 경우, 혹은 비활성하더라도 무시할 수 없는 인터럽트인 NMI 가 발생한 경우 CPU는 이러헥 우선순위 높은 인터럽트 부터 처리한다

우선순위를 반영하여 다중 인터럽트를 처리하는 방법에는 여러가지가 있으나, 대부분은 PIC(프로그래머블 인터럽트 컨트롤러) 라는 하드웨어를 사용한다.
PIC는 여러 장치 컨트롤러에 연결되어, 장치 컨트롤러에서 보낸 하드웨어 인터럽트 요청들에 대하여 우선순위를 판별하여 CPU에게 지금 처리해야할 하드웨어 인터럽트를 알려준다.

PIC에는 여러 핀이 달려 있는데, 이 핀은 각각 CPU에 하드웨어 인터럽트 요청을 보낼수 있는 약속된 하드웨어가 연결되어 있다. 그러니, 인터럽트들을 받아들이는 핀이라 생각 해도 된다. 첫번째는 키보드, 두번째 핀은 타이머 인터럽트. 이런식으로

조금더 자세히 보자
- PIC가 장치 컨트롤러에서 인터럽트 요청 신호들을 받는다
- PIC는 우선순위를 판단하여, 인터럽트 요청신호를 CPU에 보낸다.
- PIC는 데이터 버스를 통해 CPU에 인터럽트 벡터를 보낸다.
- CPU는 인터럽트 벡터를 통해 인터럽트 요청의 주체를 알게되고, 해당 장치의 인터럽트 서비스 루틴을 실행한다.

일반적으로는 더 많은 그리고 복잡한 인터럽트를 관리하기 위하여, PIC를 두 계층 이상으로 구성하고는 한다.

3) DMA 입출력
프로그램 기반 입출력과 인터럽트 기반반 입출력에 공통점이 있다면, 입출력장치와 메모리간의 데이터 이동은 CPU가 주도하고, 이동하는 데이터도 반드시 CPU를 거친다.
예를 들어 입출력 장치데이터를 메모리에 저장하는 경우, 장치 컨트롤러에서 입출력 장치 데이터를 하나씩 읽어서 레지스터에 적재하고, 적재한 데이터를 메모리에 저장한다.

이는 메모리속 데이터를 입출력 장치에 내보내는 경우에도, CPU를 반드시 거쳐야 한다.
이런 점에 있어서 모든 데이터가 반드시 CPU를 거치게 된다면, 입출력장치를 위한 연산 때문에 낭비와 부담이 커지게 된다.
이러한 점을 해결하기 위해, 입출력 장치와 메모리가 CPU를 거치지 않고 상호작용하는 입출력 방식 DMA가 등장하였다.

DMA입출력을 하기 위해선, 시스템 버스에 연결된 DMA 컨트롤러라는 하드웨어가 필요하다.

과정은 이렇다.
- CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령한다.
- DMA 컨트롤러는 CPU대신 장치컨트롤러와 상호작용하며, 입출력 작업을 수행한다. 만약 필요하다면 메모리에 직접 접근하여 정보를 읽거나 쓴다.
- 입출력 작업이 끝나면, DMA 컨트롤러는 CPU에 인터럽트를 걸어, 작업이 끝났음을 알린다.

이번에는 메모리 내의 정보를 하드 디스크에 백업하는 작업을 봐보자.
- CPU는 DMA 컨트롤러에 입출력장치의 주소, 수행할 연산, 읽거나 쓸 메모리의 주소 등과 같은 정보로 입출력 작업을 명령한다.
- DMA 컨트롤러는 CPU를 거치지 않고, 메모리와 직접 상호작용하며, 백업할 정보를 읽어오고, 이를 하드 디스크의 장치 컨트롤러에 내보낸다.
- 백업이 끝나면 DMA 컨트롤러는 CPU에게 인터럽트를 걸어 작업이 끝났음을 알린다.

위처럼 CPU는 오로지 입출력의 시작과 끝에만 관여하면 된다.
그러나, 이런 문제도 있다. DMA 컨트롤러는 시스템 버스로 메모리에 직접 접근이 가능하지만, 시스템 버스는 공공 자원이기에 동시 사용이 불가능하다.
즉 CPU가 시스템 버스를 사용할 때는 DMA 컨트롤러가 시스템 버스를 사용할 수 없다. 반대도 마찬가지고

그래서 결국 DMA 컨트롤러는 CPU가 시스템 버스를 이용하지 않을 때마다, 조금씩 시스템 버스를 이용하거나, CPU가 일시적으로 시스템 버스를 이용하지 않도록 한뒤, 시스템 버스를 집중적으로 이용한다.
이는, CPU가 버스에 접근하려는 주기를 도둑맞는다고 하여,  DMA의 시스템 버스 이용을 '사이클 스틸링' 이라고도 한다.



-입출력 버스-
CPU, 메모리, DMA 컨트롤러, 장치 컨트롤러가 모두 같은 시스템버스를 공유하는 데에서는 DMA를 위해 한번 메모리에 접근할 때마다, 시스템 버스를 두 번 사용하게 되는 부작용이 있다.
예를 들어 이렇게 되는거다. DMA 컨트롤러가 메모리와 상호작용하며서 시스템 버스를, 두번째로, 이 정보를 장치 컨트롤러로 가는데에 시스템 버스를 한번. 총 두번 말이다.

그럼 많이 시스템 버스를 DMA 컨트롤러가 사용하게 된다면, CPU는 그만큼 또 시스템 버스를 사용하지 못하게 된다.
이러한 단점을 해결하기 위해, 이런 방법이 있다.

DMA 컨트롤러와 장치 컨트롤러들을 입출력 버스 라는 별도의 버스에 연결하여 해결할 수 있다.
그렇게 된다면 시스템 버스의 사용빈도를 줄일 수 있게 된다. 대부분의 컴퓨터는 현재 입출력 버스가 있으며, 이는 입출력장치(장치 컨트롤러) 대부분은 시스템 버스가 아닌, 입출력 버스와 연결된다고 생각해도 된다.



