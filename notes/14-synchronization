1. 동기화
동시다발적으로 실행되는 프로세스들에 대하여 서로 협력하여 실행되는 프로세스들이 있다. 이때 이 프로세스들의 실행 순서와 자원의 일관성을 보장해야 하기에, 반드시 동기화 되어야 한다.
프로세스 동기화란, 즉 프로세스들 사이의 수행 시기를 맞추는 것이다. 크게 두가지 이다.
1) 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
2) 상호 배제: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기.

예를 들어보자. Writer과 Reader이라는 프로세스가 두 가지가 있다. Writer프로세스는 Book.txt 파일에 값을 저장하는 프로세스고, Reader 프로세스는 Book.txt  파일을의 저장된 내용을 읽는 프로세스다.
이럴 경우에라면 의도대로, Writer 프로세스 그리고 Reader 이런 순서대로 프로세스가 실행되어야 한다. 
이렇게 올바른 순서대로 실행하게 하는 것이 ‘실행 순서 제어’ 이다.

이제 상호 배제에 대한 예시도 봐보자. 프로세스 A와 B는 모두 계좌의 잔액을 읽고, 잔액에 2/5만원을 더하고, 더한값을 저장하는 프로세스라고 치자. 이때 프로세스 A와 B가 동시에 실행되었다고 가정하자.
초기 현재 잔액이 10만원이었다면 의도대로라면 17만원이 나와야 할것이다. 그러나, 동기화가 이루어 지지 않는 상황에서
프로세스 A가 읽어들인 값에서 2만원을 더한다는 내용을 실행하게 된 뒤에, 만약 이후 문맥 교환이 이루어지고, 프로세스 B가 동시에 실행되어, 잔액을 읽어들이게 된다면, 프로세스 B도 10만원을 대상으로 더해질 것이다.
즉 최종 잔액이 15만원과 같이 엉뚱한 결과가 나올 수 있는 것이다. 이를 위해 상호배제를 위한 동기화가 있는 것이다.
//의문점: 문맥교환이 일어나는 것은 타이머 인터럽트가 발생하였을때 아니한가..? 만약 상호배제를 위한 동기화를 적용한다면 타이머 인터럽트가 일어나더라도 무시하고 프로세스를 끝까지 실행하게끔 하는 것인가? 위의 예시에 따르면 그게 맞는거 같은데..;;//

//답: 문맥 교환은 타이머 인터럽트, I/O 인터럽트 등으로 언제든지 발생이 가능하다. 기억하자. "상호배제는 '문맥 교환 자체'를 막는 것이 아니다."
//딱 다른 프로세스가 임계 구역에 들어오는 것만 막는다.

//추가 의문점: 문맥교환은, 프로세스 A가 실행되는 도중이였다면, CPU가 프로세스 B의 정보로 바꾸는, 즉 실행 주체로 바꾸는 것이 아닌가..?
//그렇게 실행주체가 바뀐 상태였다고 치자. 그럼  아래 <79>번째 줄의 예시에 따르면, 총합++; 과 총합--:을 하였을때, 임계 구역에 프로세스가 하나씩 들어오게 되는 조건을 만족하더라도 꼬이는 것 아닌가?
//어찌 되었든 저급언어 코드들이 실행되는 도중에 문맥교환이 일어나는 것이기에..?

//추가 답: 맞다. 그러니 임계 구역이라는 개념이 있는 것이다. 우선 기억하자. 임계 구역은 '한 줄 짜리 코드' 줄이 아닌, 논리적으로 하나의 작업으로 취급되어야 하는 코드 묶음이다.
//즉 r1 = sum; r1 = r1 + 1; sum = r1; 이것은 '하나의 임계 구역' 논리적 단위가 되는 것이다.
//일단 다시 이거부터 생각하자. 임계 구역은 '그 동안의 문맥교환이 안일어난다' 이게 아니다. '그 동안 다른 실행 주체가 같은 임계 구역에 못 들어온다' 이게 맞는 것이다.

/*
lock();
r1 = sum;
r1 = r1 + 1;
sum = r1;
unlock();
   이렇게 되어있다고 하자. 이게 하나의 임계 구역인 셈이다.
그럼 실제 CPU는 이런식으로 실행된다. 이때 제대로 하기 위해, 저 저급언어 실행도중 타이머 인터럽트가 발생했다고 가정해보자.
A프로세스 시작, lock을 획득 -> r1 = sum -> 타이머 인터럽트 발생 -> OS는 문맥교환시킴 -> B 프로세스 실행시작 -> lock 시도, but, 프로세스 A가 쥐고 있으므로 실패함 = 대기 상태가 됨 
-> OS가 다시 문맥 교환시킴 -> r=r1+1 , sum = r1 실행됨 -> unlock() 실행 -> 그제서야 다시 문맥교환이 되어 B가 될때, 프로세스 시작 가능.

즉 A가 임계구역에 들어간 순간, B는 lock에 의해 접근이 불가능하며, sum이라는 공유 자원을 쓸 수 없게 된다.
*/
다른 대표적인 예시도 있다. 생산자와 소비자 문제이다. 생산자와 소비자는 ‘총합’이라는 데이터를 공유하고 있으며, 생산자는 버퍼에 물건을 넣은 후 물건의 총합에 해당하는 변수를 1 증가시킨다.
반면 소비자는 버퍼에 물건을 빼낸 후 물건의 총합에 해당하는 변수를 1감소 시키는 것이다.
이 상태에서 생산자를 100000번, 소비자도 100000번 함수를 동시에 실행한다고 치자. 초기 합계가 10이라면, 똑같이 실행 이후 합계도 10이어야 한다. 그러나 동기화가 되지 않을 경우 그러지 않다.

코드를 봐보자.
#include <iostream>
#include <queue>
#include <thread>
void produce(); //생산자 스레드
void consume(); //소비자 스레드 (프로세스 뿐만 아니라, 스레드 또한 동기화의 대상이다. 사실상 실행의 흐름을 갖는 모든 것이 동기화의 대상이다.)
//std::queue<int> q;
int sum = 0; //초기합계. 두 스레드가 같이 사용하는 변수, 후에 말하겠지만, 임계구역이 발생하는 대상이다.
int main() {
    std::cout << "초기 합계: " <<  sum << std::endl;
    std::thread producer(produce);  //새로운 스레드 생성됨. produce() 함수 독립적 실행 역할
    std::thread consumer(consume); // 마찬가지로 consume() 실행 역할

    producer.join(); //두 스레드가 끝날 때 까지 대기.
    consumer.join();
    
    std::cout << "producer, consumer 스레드 실행 이후 합계: " <<  sum << std::endl; 
    return 0;
}
void produce() {
    for(int i = 0; i < 100000; i++) {
        // q.push(1);
        sum++;
    }  //계속 1씩 더함
}

void consume() {
    for(int i = 0; i < 100000; i++) {
        // q.pop();
        sum--;
    } //계속 1씩 뺌
}

의도대로라면 0이 나와야 한다. 그러나 초기 합계: 0
/* producer, consumer 스레드 실행 이후 합계: 70214 */ 이렇게 출력이 나온다.
이는 생산자 프로세스와 소비자 프로세스가 제대로 동기화 되지 않았기 때문에 생긴 문제이다. 생산자와 소비자 모두 '총합' 이라는 변수를 동시에 사용하지만, 
소비자가 생산자의 작업이 끝나기도 전에 총합을 수정하고, 생산자도 소비자의 작업이 끝나기도 전에 총합을 수정하는 등의 일이 계속 일어나기 때문이다.


- 공유자원과 임계 구역
코드 중간 주석에 이들의 단어를 쓴적이 있다. 우선 아주 쉽게 말하면 저기에서는 '총합' 이 공유자원 이다. 즉 동시에 실행되는 프로세스들이 공유하는 자원이다.
공유자원은 전역변수, 파일, 입출력, 보조기억장치 등이 될수 있다.

그리고 이 공유 자원 중에서, 두 개이상의 프로세스를 동시에 실행하면 문제가 발생하는 자원이 있기를, 
그러한 자원에 접근하는 코드 영역을 '임계 구역' 이라고 한다.

임계 구역은 아까 말햇다시피 두 개 이상의 프로세스가 동시에 실행되면 안되는 영역이지만, 잘못된 실행으로 인해, 여러 프로세스가 동시 다발적으로 임계구역의 코드를 실행하여 문제를 일으키는 경우가 있다.
이를 '레이스 컨디션' 이라고 한다.

'레이스 컨디션이 발생하는 근본적인 이유' 는 사실 '고급언어 -> 저급언어' 변환 과정에서 생겨나는 걸로 봐도 된다.
다시 예를 들어보자.  총합 변수를 하나 증가 혹은 하나 감소 시키는 코드는 총합++; 혹은 총합--; 일것이다. 그러나 저급 언어로 변환되면,
r1 = 총합; r1 = r1+1; 총합=r1; 이런식으로 될것이다. 자 다시 과정을 봐보자.
r1 = 총합 -> r1 = r1+1 -> 이러던 도중 문맥 교환됨 -> r2 = 총합 -> r2=r2-1 -> 또 문맥 교환됨 -> 총합 =r1 -> 총합 = r2 이렇게 된다고 치자. 
초기 총합이 10이였다면 최종총합은 의도대로 10이 나오는 것이 아닌 9가 나오게 된다.

상호 배제를 위한 동기화는 이와 같은 일이 발생하지 않도록 두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 관리하는 것이다.
운영체제는 이 문제에 대해, 3가지 원칙을 지킨다.
1) 상호배제: 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.
2) 진행: 임계 구역에 어떤 프로세스도 진입하지 않았다면, 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
3) 유한 대기: 한 프로세스가 임계 구역에 진입하고 싶다면, 반드시 언젠가는 임계구역에 들어올 수 있어야 한다.



2. 동기화 기법
그러면 프로세스의 동기화가 어떻게 이루어 지는지에 대해 이제 봐보자. 대표적인 도구인 뮤텍스 락, 세마포, 모니터 이다. 

1) 뮤텍스 락
뮤텍스 락은 한마디로 ‘자물쇠’이라고 생각해도 된다.
임계 구역에 진입하는 프로세스는 ‘내가 지금 임계 구역에 있음’ 을 알리기 위해 뮤텍스 락을 이용하여 임계 구역에 자물쇠를 걸어둘 수 있고, 이를 통해 다른 프로세스가 임계구역에 진입하지 못도록 하는 것이다.

이때 자물쇠 역할을 프로세스들이 공유하는 전역 변수 lock 이고, 임게구역을 잠그는 역할을 acquire 함수, 임계구역의 잠금을 해제하는 역할을 release 함수라고 치자.
acquire 함수부터 보자. 프로세스가 임계구역에 진입하기 전에 호출하는 함수이다. 만약 임계 구역이 잠겨있다면, 임계구역이 열릴 때 까지,
즉, lock이 false가 될 때 까지 임계 구역을 반복적으로 확인하고, 임계구역이 열려 있다면 임계 구역을 잠그는, 즉 lock을 true 로 바꾸는 함수이다.
release는 단순하다. 임계 구역에서의 작업이 끝나고 호출하는 함수이며, 잠겨있던 임계구역을 열어주는 역할이다.

간단한 구현 예를 봐보자.
acquire(){
   while (lock == true)  //임계구역이 잠겨 있다면 계속 반복적으로 확인한다.
      ;
   lock = true //이때는 임계구역이 잠겨있지 않은 것으로 임계 구역을 잠금시킨다.
}
//임계 구역
release(){
   lock = false; //임계 구역 작업이 끝났으니 잠금 해제.
}


이렇게 되면 프로세스는 임계구역에 진입할 수 없다면 기다려야 하며, 획득할 수 있다면 임계 구역을 잠근뒤 임계구역에서의 작업을 진행하고, 임계구역에서 빠져나올떄 잠금을 해제한다.
물론 while문을 보면 '바쁜 대기' 즉, 실새없이 잠겨있는 것이 풀렷는지를 계속 확인하게 된다.
이는 또다른 CPU낭비이기에, 해결 방법이 있다. 방법은 바로 아래 세마포 설명에서 같이 쓰겠다.

2) 세마포
뮤텍스 락과 매우 비슷하지만, 다른점은 이거다. 뮤텍스 락은 '하나의 공유자원' 에 접근 하는 프로세스를 가정한다. 반면에, 세마포는 여러개의 프로세스가 '여러개의 공유자원' 에 접근하는 상황이다.
더 정확하게는 예시를 들면, '출력 프로세스'는 3개이지만, '공유 자원'인 프린터기는 2대가 있는 것이다. 즉 공유자원이 이런식으로 여러개 있는 것이다.

세마포에서는 이렇게 구현된다. 임계구역에 진입할 수 있는 프로세스의 개수 즉 사용가능한 공유자원의 개수를 나타내는 전역변수 S, 
임계구역에 들어가도 좋은지 기다려야 할지를 알려주는 wait함수, 임계 구역 앞에서 기다리는 프로세스에, 이제 임계구역으로 들어갈 수 있음을 알려주는 signal함수.

wait(){
   while(S<=0) //만약 임계 구역에 진입할 수 있는 프로세스 개수가 0 이하라면, 계속 사용할 수 있는 자원이 생겨나는지 반복적으로 확인한다.
   ;
   S--; //임계 구역에 진입할 수 있는 프로세스 개수가 하나 이상이면 S를 1감소 시키고 진입한다.
}
//임계 구역//
signal(){
   S++; //임계구역의 작업이 마친뒤 S를 1증가 시킨다.
}

하지만 이러한 구현은 뮤텍스락이든, 세마포든 CPU낭비가 심해진다. 그렇기에 이런 방법이 더 좋다.
wait함수는 만일 사용할 수 있는 자원이 없을 경우 '해당 프로세스 상태를 대기상태로 만들고, 그 프로세스의 PCB를 세마포를 위한 대기 큐에 삽입한다.'
이후 원래 임계 구역에 있던 프로세스가 작업이 끝나지고, 'signal' 함수를 호출하면, signal함수는 대기중인 프로세스를 대기 큐에서 빠져 나오게 한뒤, 프로세스 상태를 준비상태로 변경시키고, 준비큐로 옮겨준다.

wait(){
   S--;
   if (S<0){
      and this process to Queue;
      sleep();
   }
}
signal(){
   S++;
   if (S<=0){
      remove a process p from Queue;
      wakeup(p); //p는 대기큐에 있던 프로세스. 
   }
}

반면에, '특정 조건이 만족되어야만 실행 할 수 있는 상황에서 올바른 순서대로 실행하게 하는 것' 도 할 수 있다. 이렇게 하면 된다. S = 0 으로 두고, 먼저 실행할 프로세스 뒤에 siganl함수, 다음에 실행할 프로세스 앞에 wait함수를 붙이면 된다.
/* p1의 임계구역 -> signal // p2에 해당하는 wait() -> p2의 임계구역  */
이렇게 된다. 그럼 프로세스 p1이 먼저 실행된다고 치자. 그냥 잘 될 것이다. 그럼 반대로 p2가 먼저 실행된다고 치자.
p2가 먼저 실행이 되더라도, p2는 wait()를 만나게 되므로, p1이 임계 구역에 진입한다. S를 0으로 두엇으니까. 그리고 p1이 임계 구역의 실행을 끝내고 signal을 호출하면 그제서야 p2가 임계 구역에 진입한다.
즉 이런식으로 실행 순서 제어를 위한 동기화도 잘 해결한다.

//의문점: 하지만 세마포는 말 그대로 공유자원이 많을 것이다. 이런 경우에 S는 0이 아니는 경우가 대부분일 텐데 그렇다면, 순서를 못지키는 상황이 많이 생겨나는 것 아닌가?
//답: 맞다. 사실 세마포는 카운팅 세마포어(Counting Semaphore)와 이진 세마포어(Binary Semaphore)으로 나뉘어진다. S=0으로 잡았다면 주로 이진 세마포어이다.


3) 모니터
모니터는 공유자원과, 공유자원의 접근하기 위한 인터페이스(통로) 를 묶어서 관리한다. 그리고 프로세스는 반드시 인터페이스를 통해서만 공유자원에 접근하도록 한다. 

//의문점: 공유자원이 1개라고 치자. 인터페이스가 꼭 여러개일 필요가 있는가? 
//답: 필요없다 1개여도 된다. 오로지 정해진 방법으로만 접근을 강제하는 것 뿐이다.

이를 위해 모니터를 통해 공유자원에 접근하고자 하는 프로세스를 큐에 삽입하고, 큐에 삽입된 순서(선입선출) 대로, 하나씩 공유자원을 쓰게 한다. 
//의문점: 이러한 과정에 있어서도 모니터에 달려있는 프로세스를 저장한 큐가, CPU 스케쥴링처럼 우선순위, 에이징 등의 기법을 사용하는가?
//답: 일반적으로 사용하지 않는다. 모니터 큐는 자원을 안전하게 잠깐 보호하기 위한 줄이기에, CPU 스케줄링과 같은 정책을 적용하지 않는다.




//의문점:왜 인터페이스가 필요한 것인가? 모니터 밖 큐와, 모니터 안의 공유자원만 있으면 되는 것 아닌가?
//답: 예를 들어보자. 공유자원이 버퍼이다. 소비자는 버퍼가 비어있다면 들어가면 안되고, 생산자는 버퍼가 가득 차면 들어가면 안된다. 즉 '조건'을 지정하는 것이 인터페이스다. 즉 '규칙'의 역할을 하는 것이다.

즉, 모니터는 공유자원을 다루는 인터페이스에 접근하기 위한 큐 (모니터에 진입하기 위한 큐) 를 만들고, 모니터 안에는 항상 하나의 프로세스만 들어오도록 하여, 상호 배제를 위한 동기화를 제공한다.

이 밖에도 모니터는 세마포와 마찬가지로 실행 순서 제어를 위한 동기화도 제공한다. 특정 조건을 바탕으로 프로세스를 실행하고 일시 중단하기 위해, 모니터는 조건 변수를 사용하는데, 
조건 변수는 프로세스(스레드)의 실행순서를 제어하기 위해 사용하는 변수 이다.

조건 변수로는 wait와 signal 연산을 수행할 수 있다. 비슷하다. wait는 호출한 프로세스의 상태를 대기 상태 전환 + 일시적으로 조건 변수에 대한 대기 큐에 삽입
이때 조건은 각기 다를 수 있다. 단순히 lock 과 같은 것이 아니라, '실행 순서'도 담당하게 되는 것이다.
이때의 대기 큐는, 모니터에 진입하기 위해 삽입되는 큐와는 다르다. 

signal은 wait연산으로 일시중지된 프로세스에서, 다시 실행을 재개시키는 연산이다. 이때는 다시 큐에 있던 그 프로세스가 모니터 안으로 들어올수 있게 된다. 


조건이 만족되지 않으면 이것도 마찬가지로 '임계 구역' 에서 나가서 기다리게 하는 것이다. 이때, 아예 모니터 밖으로 내보네는 것이다.

모니터는 이러한 조건 변수를 통해 이런 동기화를 제공한다는 것이다
특정 프로세스가 아직 실행될 조건이 되지 않을 때에는 'wait'를 통해 실행을 중단한다. 그리고 실행될 조건이 충족되었을 때는 signal을 통해 실행을 재개한다.
