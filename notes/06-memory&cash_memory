1. RAM의 특징과 종류

일단 그동안 말한 메모리는 대부분 RAM을 일컫는 것을 뜻하며, 이제부터는 메모리 대신 RAM으로 말한다고 치자.
RAM에는 실행할 프로그램의 명령어와 데이터가 저장된다. 여기서 중요한 특징은 전원을 끄면 내용이 사라지는 휘발성 저장 장치라는 것이다.
반면 전원이 꺼져도 저장된 내용이 유지되는 저장장치는 비휘발성 저장 장치로, 예를 들어 하드 디스크, SSD, CD_ROM, USB 메모리와 같은 보조기억장치가 대표적이다.
그러나 보조기억장치는 전원을 꺼도 내용이 유지된다고는 하지만, CPU는 보조기억장치에 직접 접근하지 못한다. 그래서 보통 RAM에는 실행할 대상을, 보조기억장치는 보관할 대상을 저장한다.
CPU가 실행하고 싶은 프로그램이 있다면 보조기억장치에서 꺼내, RAM으로 복사하여 저장한 뒤 실행하는 것이다.

RAM용량:
CPU가 실행하고 싶은 프로그램이 보조기억장치에 있다면 이를 RAM으로 가져와야 하는데, RAM용량이 적다면 보조기억장치에서 실행할 프로그램을 가져오는 일이 잦아서 실행 시간이 길어진다.
예를 들어보자. RAM이 프로그램 하나를 저장할 수 있다면, 보조기억장치에서 다른 프로그램을 실행 할때 마다, RAM은 복사하고 저장하는 과정을 반복해야 한다.
하지만 RAM용량이 충분히 크다면 보조기억장치에서 많은 데이터를 미리 가져와 RAM에 저장할 수 있다. 그렇다면 많은 프로그램을 동시에 실행하는데 유리하게 된다.
RAM종류:

1) DRAM
Dynamic RAM의 준말이다. 즉 데이터가 동적으로 변하는 RAM을 의미한다. 다르게 이야기 하면, DRAM은 시간이 지나면 데이터가 점점 사라진다.
이 사라지는 데이터를 막기위하여 일정 주기로 데이터를 다시 저장(재활성화) 해야 한다.
이러한 단점에도 불구하고, 일반적으로 메모리로써 사용하는 RAM은 DRAM이다. 왜냐하면 소비전력이 낮고, 저렴하며, 집적도가 높기 때문이다.

2) SRAM
Static RAM이다. 저장된 데이터가 변하지 않는 RAM을 의미한다. 이러한 성질 때문에 당연히 재활성화가 필요 없고, DRAM보다 속도도 높다.  SRAM은 이때  플립플롭 구조로 데이터를 저장한다.
단, 집적도가 낮고, 소비전력도 크며, 가격도 더 비싸다. 그렇기에, SRAM은 DRAM과 달리 대용량으로 만들때, 쓰는 것이 아닌, 속도가 빨라야 하는 저장 장치에서 사용한다. 
DRAM은 주기억장치에 주로 사용되고,  SRAM은 캐시 메모리에 주로 사용된다.

3) SDRAM
클럭 신호와 동기화된, DRAM의 발전된 형태이다. 즉 클럭 타이밍에 맞춰서 CPU와 정보를 주고 받을 수 있는 RAM이다.
//의문점: 그러면 SDRAM 이 아닌경우에는 클럭신호와 동기화 되지 않은 RAM인 것인가...? 그런 RAM이라면 대체 무엇을 기준으로 작동하고, 제어신호에 맞춰서 명령어와 데이터를 CPU에 보내는가.?
//답: 맞다. 저런 DRAM을 비동기 DRAM이라고도 한다. 즉 클럭신호가 아닌 제어신호의 오로지 하강 혹은 상승 엣지만을 보고 동작하였다.

4) DDR SDRAM
대역폭을(데이터를 주고받는 길의 너비)를 넓혀서 속도를 더욱 빠르게 만든 SDRAM이다.
만약 DDR2 SDRAM이라면 기존 DDR SDRAM보다 대역폭이 2배 넓은 셈이다.



2. 메모리의 주소 공간
메모리에 저장된 정보의 위치는 주소로 나타낼 수 있으나, 주소에는 물리주소와, 논리주소로 두 종류가 있다. 
물리 주소는, 메모리 하드웨어가 사용하는, 논리주소는 CPU와 실행 중인 프로그램이 사용하는 주소이다.

우선 전제부터 이렇게 보자. CPU와 실행중인 프로그램은 현재 메모리 몇 번지에 무엇이 저장되어 있는지 다 알지 못한다. 메모리에 저장된 정보는 계속 바뀌기 때문이다.
실행이 끝난다면, 삭제되고, 새로 실행되면 생겨나고, 같은 프로그램이더라도, 실행할 때마다 적재되는 주소가 다를 수 있다.
메모리가 사용하는 물리주소는 말 그대로 정보가 실제로 저장된 하드웨어상의 주소로 위의 전제에서의 주소가 될 것이다.
반면에 논리주소는 CPU와 실행중인 프로그램이 사용하며, 실행중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소를 의미한다.

예를 더 들어보자. 게임이든 유튜브든 킨다고 가정했을때, 이들의 물리주소는 굳이 알 필요가 없다 계속 변하기 때문이다. 그래서 각각은 모두 물리 주소가 아닌 0번지 부터 시작하는 자신만을 위한 주소인 논리 주소를 가지고 있다.
즉 예를들어 ‘25’번지 라는 주소는 게임이든 유튜브든, 메모장이든 논리주소로써는 다 있는 것이다.
그리고 CPU는 이 논리주소를 받아들이고, 해석하고, 연산한다.

물론 CPU는 메모리와 상호작용을 하기에, 논리주소와 물리주소 간의 변환이 이루어져야 한다. 이 변환은 CPU와 주소버스 사이에 위치한 ‘메모리 관리 장치’(MMU) 라는 하드웨어에 의해 수행된다.

MMU는 CPU가 발생시킨 논리주소에 베이스레지스터 값을 더하여 논리주소를 물리 주소로 변환한다.

예전에 베이스 레지스터 기준변위를 배운적이 있었다. 그거와 같다. 다른점 이라고는 이거다. 
기존에는 이 명령어가 어디 주소를 가르키는가에 대하여, 오퍼랜드와 주소지정방식을 이용하여,
이번 경우에는 논리주소를 물리주소로 변환하기 위하여, MMU를 사용할때, 베이스 및 한계 레지스터를 사용하는 경우다.
베이스 레지스터는 프로그램의 첫 물리주소를 저장하게 되고, 논리주소는 프로그램의 시작점으로부터 떨어진 거리인 셈이다.

- 메모리 보호기법
다른 프로그램의 영역을 침범할 수 있는 명령어에 대하여 위험성을 없애기 위해, 논리 주소 범위를 벗어나는 명령어 실행을 방지하고, 실행 중인 프로그램이 다른 프로그램에 영향을 받지 않도록 하는 방법이 필요하다.
이를 ‘한계 레지스터’ 가 담당한다. 베이스 레지스터는 프로그램의 가장 작은 물리주소를 저장하는 반면, 한계 레지스터는 논리주소의 최대 크기를 저장한다. 즉 프로그램의 물리주소 범위는 
베이스 레지스터 값의 이상과 베이스 레지스터 값 + 한계 레지스터 값 미만이 된다.

예를 들어보자. 베이스 레지스터에 100이고, 한계 레지스터는 150이 저장되어 있다고 치자. 
그렇다면 이 프로그램은 물리주소로 메모리에 100번지부터 250까지 있는 것이다., MMU는 베이스 레지스터에 논리주소를 더하는 것이므로, 한계 레지스터의 값 150을 넘기면 안된다.
즉 이 프로그램은 150번지를 넘어가는 논리 주소를 가질 수 없다.
만약 CPU가 한계 레지스터보다 높은 논리 주소에 접근하려고 하면 인터랩트(트랩)을 발생시켜서 실행을 중단시킨다.

