1. 보조기억장치
보조기억 장치는 하드 디스크와 플래시 메모리가 있다. 플래시 메모리는 흔히 USB, SD카드, SSD와 같은 저장 장치이다.
1) 하드디스크
자기적인 방식으로 데이터를 저장하는 보조기억장치이다. 하드디스크에서 실질적으로 데이터가 저장되는 것은 동그란 원판으로, ‘플래터’라 부른다. 플래터는 자기 물질로 덮여 있어서, 수만은 N극, S극 으로 저장한다. 각각 0과 1의 역할을 한다.
이 플래터를 회전시키는 것을 ‘스핀들’ 스핀들이 돌리는 속도를 RPM단위로 부른다.
예를 들어 RPM이 15000인 하드 디스크는 1분에 15000번 회전하는 하드디스크인 것이다.
플래터를 대상으로 데이터를 읽고 쓰는 구성 요소는 바늘처럼 생긴 부품으로 ‘헤드’이다.  이 헤드의 위치를 조절하고 이동시키는 것은 ‘디스크 암’ 이다.
하드 디스크는 여러 양의 데이터를 저장해야 하므로, 보통 여러개의 플래터로 이루어져 있으며, 이 플래터는 앞 뒤로 헤드를 사용한다면, 양면을 이용할 수 있다.

이제 어떻게 저장되는지 보자. 플래터는 ‘트랙’ 과 ‘섹터’ 단위로 데이터를 저장한다.플래터를 여러 동심원으로 나누었을때, 그중 하나의 원을 트랙으로 부른다.
운동장을 예시로 봐보자. 1번 트랙, 2번트랙 원이 있는 것이다. 마찬가지다.
만약 플래터의 여러겹에 있어서 같은 트랙에 위치한 것을, 그 단위를 실린더라고 한다.

섹터는 여러조각으로 나뉘어 지거니와 그 한 조각을 의미하며, 이는 하드 디스크의 가장 작은 전송단위이다.
일반적으로는 하나의 섹터는 개개인의 차이가 있으나, 대략 512바이트의 크기를 가지고 있다.

연속된 정보는 보통 한 실린더에 기록된다. 이러한 이유에서는 단순하다. 디스크 암을 따로 조정하지 않고도 바로 데이터에 접근할 수 있기 때문이다.

-하드디스크의 고려해야 할 시간-
탐색시간: 접근하려는 데이터가 저장된 트랙까지 헤드를 이동시키는 시간
회전시간: 헤드가 있는 곳으로 플래터를 회전시키는 시간
전송시간: 하드디스크와 컴퓨터간의 데이터를 전송하는 시간.

하드디스크는 탐색 시간과 회전 시간이 성능에 좌지우지가된다.

2) 플래시 메모리
전기적으로 데이터를 읽고 쓸 수 있는 반도체 기반의 저장 장치이다. 보조기억장치로 보고는 하지만, 다양한 곳에서 널리 사용한다. 예를 들어, ROM에도 사용되고, 다른 전자제품 안에 플래시 메모리가 내장되어 있기도 한다.
플래시 메모리는 ‘셀’ 이라는 데이터 저장 단위가 있으며, 이 셀이 모여서 MB와 같은 용량을 같는 저장 장치가 되는 것이다.
이 셀 하나에 대해 몇 비트를 저장할 수 있느냐에 따라 플래시 메모리의 종류가 달라지며,
한 셀에 1비트를 저장할 수 있다면 SLC, 2비트는 MLC, 3비트는 TLC 타입이라고 한다.

이제 각각의 타입에 대하여 특징을 봐보자.
SLC: 한 셀로 2개의 정보표현 가능, 출입이 자유롭기에 빠른 입출력, 수명이 매우 김. 그러나 용량대비(1비트) 가격이 매우 비싸다.
MLC: 한 셀로  4개의 정보표현 가능. 속도와 수명은 SLC보다 안좋으나, 대용량화 하기 쉽다. 여러 비트를 한번에  저장 할 수 있기에. 또한 용량 대비 비용이 저렴하다
TLC: 한 셀당 3비트로 여덟 개의 정보를 표현할 수 있다. 수명과 속도가 짧고 느리지만, 용량대비 가격이 제일 저렴하다.

셀들이 모여져 만들어진 하나의 단위를 ‘페이지’, 페이지가 모이면, ‘블록’, 블록이 모이면 ‘플레인’, 마지막으로 플레인들이 모인 단위를 ‘다이’ 라고 한다.
플래시 메모리에서 읽기와 쓰기는 페이지 단위로 이루어지며, 삭제는 블록 단위로 이루어져 있다.

이때 페이지는 3가지의 상태가 있다.
Free: 어떠한 데이터도 저장하고  있지 않아, 새로운 데이터를 저장할 수 있는 상태
Vaild: 유효 데이터 저장 상태
Invaild: 유효하지 않은 데이터를 저장한 상태

그러나, 플래시 메모리는 하드디스크와는 다르게 덮어쓰기가 불가능하다. 예를 들어보자. 어떤 블록에 대하여 4개의 페이지가 있다고 치자.
이미 이 페이지에는 데이터 A가 있다. 이 데이터 A를 B로 변경하고 싶다 하더라도, 바로 변경되는 것이 아닌, 새로운 데이터 B가 Free상태의 페이지로 갈 뿐이지, A는 사라지지 않는다.
단지 Invaild 상태로 변환 될 뿐이다. 즉 쓰레기 데이터를 차지하는 용량이 생기게 된 것으로 낭비가 생긴다.
+) 최근에는 이런 쓰레기 데이터를 정리하기 위해 ‘가비지 컬렉션’ 기능을 추가하였다. 이는 유효 페이지만 새로운 블록으로 복사한뒤, 기존 블록 전체를 지우는 것이다. 
이렇게 된다면 invaild 상태 페이지 였던 A 영역도 사라지게 되니까..



2. RAID의 정의와 종류
구글과 같은 서버는 매일 매시간 수억 데이터에 서버에 쏟아 질텐데, 어떻게 데이터를 저장하게 될까?
이런 막대한 정보량에 대해서는 RAID방법을 이용한다.  RAID는 하드 디스크와 SSD를 이용하며, 데이터의 안정성과 성능을 위하여, 여러개의 물리적 보조기억장치를 하나의 보조기억장치처럼 사용하는 기술이다.
여러개의 보조기억장치를 하나의 장치처럼 사용하는데, RAID를 구성하는 방법은 여러가지가 있다. 이를 RAID레벨이라 하는데, 대표적으로 쓰이는  RAID 0,1,4,5,6 에 대해서만 우선 보자.

1) RAID 0
여러개의 보조기억장치에 데이터를 단순히 나누어 저장하는 것이다. 저장하려는 데이터가 4TB이고 보조기억장치 하드디스크가 4개라면 각각 1TB씩 저장하는 것이다. 
이때 저장방식이 데이터에 대하여 연속적으로 어느 부분을 어느 디스크가 차지하는 것이 아닌 번갈아가며 데이터를 저장하게 된다.
이렇게 분산되어 저장된 데이터를 스트라입, 저장하는 과정을 스트라이핑이라고 한다.
이런식으로 저장하는 이유는 간단하다. 여러개의 보조기억장치를 사용하기에, 빠르게 이용하기 위해서다. 
만약 하나하나 연속적으로 데이터를 저장하게 된다면, 한 보조기억장치의 데이터를 다 읽은 후에야 다음 보조기억장치에 접근할 것이다. 효율이 떨어진다.
하지만 스트라이핑 형식으로 저장한다면, 데이터를 읽을때, 여러개의 보조기억장치를 거의 동시에 사용하게 되게 된다.
물론, RAID 0 방식은 다 좋지만, 만약 많은 디스크 중에서 하나라도 망가지게 된다면, 다른 모든 하드디스크의 정보를 읽는데도 차질 혹은 문제가 생길 수 밖에 없게 된다.
2) RAID 1
이 방법은 복사본을 만드는 방식이며, 미러링 이라고도 부른다. RAID 0 과 비슷하게 스트라이핑은 하지만, 이 스트라이핑 한 디스크들에 대하여 모두 한번에 똑같이 복제한 것이다.
동시에, 단점인 일부 데이터 손실에 대한 전체 데이터 문제를 막기 위해 ‘백업’ 즉 복사본을 하나더 만드는 방식이다.
확실히 안정성이 있고, 복구가 매우 간단하는 장점이 있다. 그렇지만 단점은 바로 보이듯, 정보를 차지하는  용량에 대하여, 이론적으로는 데이터터 비해, 두배를 차지하게 된다.

3) RAID 4
RAID1 처럼 완전한 복사본을 만드는 대신, 오류를 검출하고 복구하기 위한 정보를 저장한다.
이를 패리티 비트(코드) 라고 한다.

+) 패리티 비트
기본적으로 데이터의 오류를 검출하기 위하여, 전체 ‘1’의 개수를 짝수/홀수 로 맞추는 보조 비트이다.
단일, 병렬의 패리티로 종류가 있지만, 단일 패리티는 어디에서 에러가 났는지를 모르는 경우가 대다수이기에 병렬 패리티를 혹은 해밍 코드를 이용한다.

+추가) 해밍 코드 (RAID에서는 쓰이지 않음)
패리티 비트 수를 p, 데이터 비트 수를 d라고 한다고 치자. 
그리고 해밍코드의 패리티 비트는 여러개 들어가는데, 1,2,4,8 으로 2의 거듭제곱 위치이다. 이를 기호 P으로 표현하며 나머지는 D으로 표기한다. 즉 비트 위치가 2의 거듭제곱인 곳은 패리티 비트(P) 이다. D는 데이터 비트이다.
(이유: 1은 0001, 2는 0010, 4는 0100, 8은 1000이다. 즉 고유 자릿수를 대표하는 것과 같다)
예를 들어보자. 원본데이터가 00101110 이다.
그렇다면 자리번호(비트위치)가 1~12 으로 있을때, 2의 거듭제곱 위치에는 패리티 비트를 위치시킨다 이렇게 된다.
P1, P2, 0, P4, 0 1 0 P8 1 1 1 0 
이때,  실제 데이터 0 혹은 1이 들어간 자리를 D으로 쓴다.
각 패리티 비트는 자기 번호를 이진수로 표현했을 때, 1이 포함된 위치들을 검사한다. 
예를 들어 비트위치 6은 이진수로 0110이므로, P2, P4의 검사 영역에 포함된다. 그리고 각 패리티 비트에 대하여, 
자기 영역에 속한 데이터 비트(D)들만 XOR(홀수개의 1이 나오면 연산결과가 1)의 연산을 취한다.

이런식으로 계산하면 

이후 코드에 대해 패리티 검사를 다시 해본다. 이때 패리티 자기자신을 포함하여 XOR연산을 수행하며, 짝수 패리티 기준으로 XOR 결과가 1이면 해당 패리티 비트가 오류를 감지한 것이다.
이후에는 짝수 패리티가 되도록, 패리티 비트 값을 결정한다. 예를 들어 데이터 비트의 1의 수가 홀수라면 패리티 비트는 1이 된다.

더 예를 들어보자. P1을 보자. 검사 포함 위치는 P를 제외하고 D만을 봤을때, 3,5,7,9,11 이다. (0011, 0101, 0111, 1001, 1011 으로 2진수의 1의자리가 1)
이제 원본 데이터에 따라 봐보자. 3:0, 5:0, 7:0, 9:1, 11:1 이다. XOR은 0이 나온다. 즉 짝수개이므로 (1의 개수가) P1은 0이다.
마찬가지로 P2를 보자. 3,6,7,10,11 이 영역이며, 이는 각각 3:0, 6:1, 7:0, 10:1, 11:1 으로 XOR연산 결과 1이다.
즉 1의 개수가 홀수개 이므로 짝수를 맞추기 위해 P2 = 1 이 된다.

따라서 P1, P2, 0, P4, 0 1 0 P8 1 1 1 0  에 있어서, P1~P8 영역에 있어서 0111 으로 P가 된다., 전체 해밍코드는 0101 0101 1110이 된다. 

이후 이제 저 해밍코드를 써먹어야 한다. 어떠한 오류코드에 대하여, 수신이 되었다고 치자.
그리고 다시 P1~P8 에 대하여 XOR연산을 취하는 것이다. 단 이번에는 패리티를 포함해서 말이다.
앞에서 만들었던 해밍코드에 의하면, 이미 다 구한 후, 패리티를 포함하여 짝수로 모두 맞췄기에, 연산결과가 1(홀수)으로 나온다면 비정상 인것이다.

예를 들어, 그렇게 구하였는데, P1와 P4에서 연산결과가 1이 나왔다면 그 번호를 합친 5번째 비트에 오류가 발생됨을 의미한다.
만약 오류가 포함된 코드가 0101 '1'100 1110이였다면, 5번째 비트를 뒤집으면 된다.
수정후에는 0101 0101 1110이 된다.
//하지만 기억하자. 해밍코드는 비트 기준이고, RAID 의 패리티는 디스크 기준이다. 둘이 연관되어 사용되지는 않는다.

4) RAID 5
패리티가 저장된 장치를 따로 하나 더 두는것이 RAID4 이라면 RAID5 방법은 이 패리티 정보 마저, 하드 디스크에 나눠서 분산하여 저장하는 방식이다.

5) RAID 6 
RAID 5와 비슷하다. 그러나, 한 디스크 안에, 서로 다른 두개의 패리티를 넣는 것이다. 즉 복구 수단이 늘어 난 것으로, 
전의 방식에 비하여 안정성은 높아지고, 속도는 느려진다.


