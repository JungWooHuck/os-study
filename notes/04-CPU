CPU의 작동원리

1. ALU와 제어장치
우선 ALU의 대략적인 정보처리 과정을 보자. 
제어장치에서 우선 제어 신호를 받으며, 레지스터(저장장치) 로부터의 피연산자들을 받는다. 이후에 결과값을 다른 레지스터에 저장하고, 이에 따른 플래그를 플래그 레지스터에 저장한다.
ALU가 내보내는 결과는 특정 숫자나 문자가 될 수 있고, 메모리 주소가 될 수 있다. 이 정보는 우선은 메모리에 무작정 저장되지 않고, 임시로 레지스터에 저장된다. 
왜냐하면, CPU는 자신의 내부에 있는 레지스터에 접근하는 속도가 외부로 접근해야 하는 메모리보다 속도가 훨씬 빠르기 때문이다.
플래그는 연산 결과에 대한 추가적인 상태정보를 일컫으며, 여러가지 종류가 있다. 대표적으로는 부호,제로,캐리,오버플로우,인터럽트,슈퍼바이저 플래그가 있다. 각각 0 혹은 1로 상태를 표시 한다.
이러한 플래그들은 플래그 레지스터에 저장된다. 예를 들어서 ALU가 연산을 수행한 후에 부호 플래그가 1이 된 것이라면 계산 결과가 음수라는 뜻이다. 

제어장치:
제어장치는 이전에 제어신호를 내보내고, 명령어를 해석하는 부품이라 설명했었다. 조금 더 자세히 봐보자.
1) 제어장치는 클럭 신호를 받아들인다.
클럭 신호란 주기적으로 0,1,0,1 으로 반복되는 규칙적인 신호이다. 대표적으로 레지스터의 구성요소 중 하나인 플립플롭은 클록에 의해 상승 혹은 하강하는 순간만 입력을 읽는다. 
이런식으로 ALU도 클럭 신호를 읽는 것은 마찬가지 이다.

2) 제어장치는 해석해야 할 명령어를 받아들인다.
CPU가 해석해야 할 명령어는 명령어 레지스터라는 레지스터에 저장된다. 제어장치는 명령어 레지스터로부터 해석할 명령어를 받아들이고 해석한 뒤, 제어 신호를 발생시켜, 컴퓨터 부품들에게 수행해야 할 것을 알려준다.

3) 플래그 레지스터 안, 플래그 값을 받아 들인다.

4) 시스템 버스, 그중에서 제어버스로 전달된 제어 신호를 받아들인다.
제어 신호는 CPU뿐만 아니라, 입출력장치와 같은 외부장치도 발생 시킬 수 있다. 이를 제어버스를 통해 외부 신호를 받아 들이는 것이다.
만약 제어장치가 CPU외부에 제어신호를 전달 하게 될 경우에도 이 제어버스를 통해 내보낸다는 것이다.
예를 들어 메모리에 저장된 값을 읽거나, 메모리에 새로운 값을 쓰고 싶다면, 메모리에 제어신호를 보낸다. 
내부에 제어신호를 전달할때는 ALU와 레지스터에 전달하게 된다. 수행할 연산 지시 혹은, 데이터 이동 및 레지스터에 있는 명령어를 해석하려 할때 전달한다.



2. 레지스터
레지스터는 크게 8가지로 나뉘어져 있다. 이제 천천히 봐보자.
1) 프로그램 카운터: 메모리에서 가져올 명령어의 주소, 즉 메모리에서 읽어 들일 명령어의 주소를 저장한다.
2) 명령어 레지스터: 방금 메모리에서 읽어들인 명령어를 저장한다. 주로 명령어를 해석하려 하기 위해, 저장하는 레지스터이다.
3) 메모리 주소 레지스터: 말 그대로 메모리의 주소를 저장하는 레지스터다. 예컨대, CPU가 1000번째 주소에 있는 값을 읽을려고 할때, 이 주소값을 주소버스로 보낼때 사용된다.
4) 메모리 버퍼 레지스터: 메모리와 주고받을 값(데이터와 명령어)을 저장하는 레지스터이다.
예시를 들으면서 우선 저 위의 4가지의 레지스터의 사용을 쉽게 봐보자.

CPU로 실행할 프로그램이 1000번지부터,  1500번지까지 메모리에 저장되어 있다고 하자, 그리고 1000번지에는 1101(2) 이 저장되어 있다고 치자.
프로그램을 처음부터 실행하기 위해, 프로그램 카운터에 1000이 저장된다. 이는 메모리에서 가져올 명령어가 1000번지 주소에 있다는 것이다.
이후 주소에 있는 값을 알기 위하여 프로그램 카운터에서 메모리 주소 레지스터에 1000을 보내어 저장한다. 그리고나서, 메모리 읽기 제어신호와 메모리 주소 레지스터값이 각각 제어버스와 주소 버스를 통에 1000번지에 있던 값 1101을 가지고 온다. 
그리고 이 가져온 값을 데이터 버스를 통해 메모리 버퍼 레지스터로 전달되고, 프로그램 카운터는 1이 증가하여 1001이 된다. 
마지막으로 메모리 버퍼 레지스터에 저장된 값은 명령어 레지스터로 이동한다.
이제 다음에는 프로그램 카운터 값이 증거한 것에 따라서, 1001번지의 주소에 대해 
메모리 주소 레지스터, 제어신호-> 메모리 버퍼레지스터-> 프로그램 카운터+1 -> 명령어 레지스터 를 반복하는 셈이다.
물론 명령어 중 JUMP, CALL, RET 과 같이, 특정 메모리 주소부터 시작하라는 것을 만나게 된다면 프로그램 카운터는 그대로 +1이 아닌, 그 번지로 저장된다.
5) 범용 레지스터: 자유롭게 사용 가능한 레지스터이다.
6) 플래그 레지스터: ALU 연산 결과에 따른 플래그, 혹은 CPU상태를 저장하는 레지스터




특정 레지스터를 이용한 주소 지정방식
스택 주소 지정방식:
스택포인터는 스택 주소 지정방식이라는 것에 사용된다. 스택은 후입선출의 방식의 자료구조이다. 여기에서 스택포인터는 스택의 top을 가르키는 레지스터라 생각 하면 된다.
스택은 메모리 안에 있으며, 정확히는 메모리 안에 스택처럼 사용할 영역이 정해져 있다.

변위 주소 지정방식:
명령어는 연산코드와 오퍼랜드로 이루어져 있다. 그리고 오퍼랜드 필드에는 메모리의 주소가 담길 때가 있다. 이 상황에서 변위 주소 지정방식은 오퍼랜드 필드의 값과 특정 레지스터의 값을 더하여 유효주소를 얻어내는 방식이다.
그래서 이 방식을 이용하는 명령어는 연산코드 필드, 어떤 레지스터의 값과 더할지를 나타내는 레지스터 필드, 그리고 주소를 담고있는 오퍼랜드 필드가 있다.
//
의문점: 결국 레지스터 필드가 있다면, 이 또한 메모리 공간의 손해가 아니한가..? 그리고 왜 뭔가를 더해서 유효주소를 얻게끔 해야 하는 것인가...? 그 연산 시간또한 손해 아닌가..?
답:아니다 오히려 메모리를 절약하는 효과가 된다. 생각해보자. 레지스터 없이 만약 전부 주소를 넣는다고 치면 그 주소에 따라 그 긴 번호들을 적어야 하게 된다. 
반면에 저 방법은 그냥 기준으로 한 주소를 넣은뒤, 짧은 거리에 대한 변위(오퍼랜드)만을 쓰면 된다. 또한 주소 덧셈은 ALU에서 1클럭이면 끝날 정도로, 주소 계산 비용은 무시해도 될 정도이다.
//
이때 오퍼랜드 필드의 주소와 어떤 레지스터를 더하는지에 따라 상대 주소 지정, 베이스 레지스터 주조 로 나뉜다.

1) 상대 주소 지정 방식
오퍼랜드와 프로그램 카운터의 값을 더하여 유효주소를 얻는 방식이다. 예컨대, 이미 프로그램 카운터에는 읽어들일 실행할 명령어의 주소 저장되어 있다. 
이 상황에서 만약 오퍼랜드가 음수 -3 이었다면 CPU는 읽기로 한 명령어로부터 메모리의 세칸 이전 번지 명령어를 실행하게 한다.

2) 베이스 레지스터 주소 지정 방식
오퍼랜드와 베이스 레지스터의 값을 더하여 유효 주소를 얻는 방식이다.
여기서 베이스 레지스터는 기준 주소가 되고, 오퍼랜드는 기준 주소로부터 떨어진 거리 역할을 한다.
예를 들어, 베이스 레지스터에는 200의 값이, 그리고, 오퍼랜드가 20이라면 200번지로부터 20만큼 떨어진 220번지로 접근하라는 뜻이다.

의문점: ...? 그러면 상대 주소 지정방식과 대체 차이점이 무엇인가..? 딱히 차이점이 없어 보이는데?
의문점:지금 예시들을 보면 오퍼랜드에는 항상 값으로 적용하여 이야기 하였는데, 그럼 저 두방식을 사용할 경우에는 오퍼랜드 필드에 데이터가 저장된 위치를 명시할때, 항상 즉시 주소 지정 방식 혹은 직접 주소 지정방식만을 사용하는 것인가?

답: 우선 확실히 보이는 차이점은 기준점에 대해서이다. 상대 주소 지정방식은 유효주소가 프로그램 카운터로, 자동으로 계속 변환되는 값이다. 그에 반해, 베이스 레지스터는 ‘프로그램 시작 주소’ 으로 잘 변하지 않는다.
답: 오퍼랜드 필드에 이때 들어가는 것은 ‘변위 값’이다. 데이터도 주소도 아니다. 그러니까 연산에 바로 쓰는 데이터 값도, 데이터의 메모리 위치 주소도 아니다.

의문점: 저렇게 만약 저장하게 된다면, 데이터 5를 저장하는 것과 변위값 5를 저장하는것에 대해서 공간적 차지는 똑같은가? 동시에 오퍼랜드에 저장된 5라는 것이 변위값인지 데이터인지 어떻게 분별하는가?

답: 맞긴하다. 그대로 5가 데이터는 변위값이든 동일한 비트 패턴을 취한다. 중요한 것은 연산코드이다.
연산코드가 어떻게 이 값을 쓰는지 지시하느냐에 따라 의미가 달라진다.

예를 들어보자
ADD R1, #5  //이것은 즉시 주소 지정으로, 오퍼랜드 5를 그대로 데이터로 쓴다.
JUMP +5 //이것은 상대 주소 지정으로 현재 프로그램카운터가 가르키고 있는 메모리 주소로부터 5칸 뒤 주소로 접근한다.
LOAD R1, [BASE + 5] //이것은 베이스 레지스터 주소 지정으로,  베이스 레지스터의 값으로부터 5를 더한 후에 그 주소에 접근한다. 
이런식으로 연산코드에 따라 달라진다.
애매하지만.. 이렇게 연상을 해보자. C코드로 봤을때, 배열은 베이스 레지스터이다. if/while문은 상대 주소 지정방식이다. 
배열의 첫주소는 계속 고정되며, 이 고정 주소로부터 변위값을 통해 값에 접근하듯. 
If/while문은 코드가 계속 진행되다가, 이후에 만나고, 현재 실행 중인 명령의 다음주소를 기준으로 그 결과값에 따라 다른 주소에 접근하게 될때, 그때의 프로그램 카운터 기준으로 변위값을 통해 접근을 바꾸는 것처럼.



3. 명령어 사이클과 인터럽트

CPU가 하나의 명령어를 처리하는 과정에는 어떤 정해진 흐름이 있고, 그 흐름을 반복하며 명령어들을 처리해 나간다. 이 흐름을 명령어 사이클이라 하고, 이 흐름이 끊어지는 상황을 인터럽트라고 한다.

명령어 사이클: 프로그램 속 각각의 명령어들은 일정한 주기가 반복되며 실행되는데, 이 주기를 명령어 사이클이라 한다.

명령어를 메모리에서 CPU로 가져와야 하는 것이 첫번째이다. 이를 인출 사이클 이라고 한다.
이 인출 사이클의 과정을 레지스터에서 봐왔던  프로그램 카운터->메모리주소 레지스터, 제어신호->프로그램 카운터+1, 메모리 버퍼 레지스터-> 명령어 레지스터  // 이 과정에 속하기도 하다.

이제 명령어를 CPU로 인출했다면 CPU로 가져온 명령어를 실행하는 단계를 실행 사이클이라고 한다. 제어장치가 명령어 레지스터에 담긴 값을 해석하고, 제어 신호를 발생시키는 단계이다.

그래서 CPU는 이를 계속 반복하는 것이다. 인출 사이클과 실행 사이클을 왔다 갔다 하면서 말이다. 물론 이렇게만 계속 간단 한것은 아니다. 당장에 간접 주소 지정 방식만 보더라도, 오퍼랜드의 유효 주소의 주소를 적은 것이다. 
즉 CPU로 명령어를 인출 사이클을 통해 가져 왔다고 하더라도, 바로 실행 사이클로 못가고, 메모리 접근을 한번 더 해야 한다. 이를 간접 사이클이라고 한다.

 

인터럽트:

1) 동기 인터럽트:

CPU에 의해 발생하는 인터럽트이다. 명령어들을 수행하다가, 오류와 같은 현상을 겪었을 때 바로 발생하는 것이다. 이 때문에 ‘예외’ 라고도 동기 인터럽트를 부르기도 한다.

2) 비동기 인터럽트:

주로 입출력장치에 의해 발생하는 인터럽트이다. 이 인터럽트는 이런 역할을 하는것이다. 예컨대 CPU가 프린터와 같은 장치에 입출력 작업을 부탁한다. 그리고 프린터가 작업을 끝내면 입출력 장치가 CPU에 완료 알림을 보낸다. 이 완료알림이 인터럽트 이다.

이러한 점 떄문에, 하드웨어 인터럽트라고도 부르기도 한다.

즉 오류와 예외와는 다르게, 알림과 같은 역할을 하게 된다. 앞의 예시에서 다시 봐보자. 입출력 장치는 CPU보다 속도가 훨씬 느리기 때문에, CPU는 입출력 작업의 결과를 바로 볼 수 없다.
이때 만약 하드웨어 인터럽트를 사용하지 않는다면, CPU는 항상 주기적으로 프린터의 완료 여부를 확인해야 하는 즉, 다른 일을 할수 없게 되는 사이클 낭비를 하게 된다. 반면에 사용하게 된다면, 기다리는 도중에도 계속 다른 작업을 할 수 있게 되는 것이다.

 

하드웨어 인터럽트 처리순서에 대해서 이제 보자.

전체적인 순서는 이것이다.

(1) 입출력 장치는 CPU에 인터럽트 요청 신호를 보낸다.

(2) CPU는 실행 사이클이 끝나고 명령어를 인출하기 전 항상 인터럽트 여부를 확인한다.

(3) CPU는 인터럽트 요청을 확인하고 인터럽트 플래그를 통해 현재 인터럽트를 받아들일 수 있는지 여부를 확인한다.

(4) 받아들일 수 있다면 CPU는 지금까지의 작업을 백업한다,

(5) CPU는 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴을 실행한다.

(6) 인터럽트 서비스 루틴이 끝나면 (4) 에서 백업해 둔 작업을 복구하여 실행을 재개한다.

 

용어들에서 우선 정리해보자.

인터럽트 요청 신호: 인터럽트는 CPU의 사이클 흐름을 끊는 것이기에, 인터럽트하기 전에는 CPU에 요청을 해야 한다.

인터럽트 플래그: 위의 인터럽트 요청을 받아내기 위해서는 플래그 레지스터의 인터럽트 플래그가 활성화 되어 있어야 한다.이 플래그는  하드웨어 인터럽트를 받아들일지, 혹은 무시할지를 결정하는 플래그이다.

(단, 이런 인터럽트 플래그로도 막을 수 없는 인터럽트 요청도 있다. 예를 들어 정전이나, 하드웨어 고장에 의한 인터럽트이다.)

인터럽트 서비스 루틴: 인터럽트 요청을 CPU가 받아들이기로 했다면 실행하는 프로그램이다. 이 프로그램은 어떤 각각의 외부 요청에 대하여 어떤 경우에는 어떻게 작동해야 하는지, 인터럽트가 발생 할때, 어떻게 처리하고 작동해야 할지에 대한 정보로 이루어져 있는 프로그램이다.

그리고 CPU가 인터럽트를 처리 한다는 것은. ‘인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아 온다’ 와 같다.

인터럽트 서비스 루틴은 다른 프로그램과 마찬가지로 명령어와 데이터로 이루어져 있다. 그렇기에 인터럽트 서비스 루틴도 프로그램 카운터를 비롯한 레지스터들을 사용하며 실행된다.

이때, 인터럽트 서비스 루틴으로 갔을 떄의 프로그램 카운터가 그냥 바로 원래 실행중이였던 프로그램주소에서 덮어버리면 문제가 생긴다. 그렇기에, 현재 프로그램 카운터 및 프로그램을 재개하기 위해 필요한 모든 내용을 스택에 백업한다.

인터럽트 벡터: 예컨대, 인터럽트 서비스 루틴은 각각의 인터럽트에 대하여 정리되어 있고, 즉 수가 매우 많기에, 구분해야 한다. 이 구분하는 것에 있어서의 식별 정보를 말하는 것이다.

인터럽트 벡터를 알면 인터럽트 서비스 루틴의 시작주소를 아는 것으로, 벡터를 통해 특정 인터럽트 서비스 루틴을 처음부터 실행할 수 있다. 
즉 외부장치가 인터럽트가 발생하고, CPU에서 받아낸 상황이라면, 인터럽트 서비스 루틴을 실행하기 위해 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴의 메모리 시작 주소를 알아내고, 이 시작 주소부터 실행해 나가면서 인터럽트 서비스 루틴을 실행한다.

 

자 이제 한번에 정리해보자. CPU 는 인출 사이클과 실행사이클을 계속 반복하며 명령어들을 처리한다.

만약 메모리 접근이 더 필요할 경우에는 간접 사이클을 중간에 더 거치게 된다.

외부장치에서 하드웨어 인터럽트를 요청한다면 CPU의 플래그 레지스터의 인터럽트 플래그를 체크한다

-> ‘가능’으로 설정되어 있다면 현재 프로그램의 프로그램 카운터, 등의 정보들을 메모리 스택 영역에 백업한다

-> 이후에 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴의 시작 주소를 알아낸다.

-> 알아낸 시작주소를 기준으로 해당 상황에 맞는 인터럽트 서비스 루틴을 실행한다. 실행하면서 인터럽트를 처리한다.

-> 메모리 스택 영역 백업해 놓은 데이터를 복구한후, 다시 기존 작업으로 점프한다. 이후 재개한다.

 

//의문점: ...앞에서의 하드웨어 인터럽트는 프린터기로 예시를 들었었다. 출력이 끝나면 인터럽트 신호를 보내는 것으로. 알림 처럼 말이다. 하지만.. 계속 보면 볼수록 알림의 역할이 아닌 오로지 요청의 역할아닌가..?;

//답: 맞다. 인터럽트는 외부 장치가 CPU에게 특정 처리를 수행해 달라고 요청하는 신호이며, 그 계기가 보통 ‘작업 완료’이기 때문에 알림처럼 느껴진다. 요청으로 보는게 더 정확하다.

 

 

 



