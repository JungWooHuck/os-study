CPU 스케쥴링 
1. 개요
모든 프로세스는 CPU를 필요로 하고, 먼저 CPU를 이용하고 싶어한다. 이 프로세스들에 대하여 운영체제가 공정하고 합리적으로 CPU자원을 배분하는 것을 CPU 스케쥴링이라고 한다.
우선 우선순위에 대해서 보자. 일반적으로 우선순위 높은 프로세스에는 ‘입출력 작업이 많은 프로세스’가 있다.

잘 생각해보자. 프로세스는 대부분 CPU과 입출력 장치를 이용하게 된다. 즉 실행상태와 대기상태를 반복하며 실행 된다는 것이다.
그런데 이러한 것들에도 CPU를 사용 시간이 더 많으냐와, 입출력장치 사용 시간이 더 많느냐에 따라, 다르게 분리하곤 한다.
각각 CPU 집중 프로세스, 입출력 집중 프로세스라고 하며, 입출력 프로세스는 실행상태 보다는 입출력을 위한 대기상태에, CPU는 실행상태에 더 많이 머무르게 된다.
이때 이 CPU를 이용하는 작업과, 입출력장치를 기다리는 작업을 CPU/입출력 버스트 라고도 부른다.

다시 봐보자. 입출력 집중 프로세스를 우선순위를 높게 두어 만약 가능한 빨리 실행시킨다고 시키자. 어차피 이 프로세스는 CPU를 많이 사용하지 않고, 당분간 대기상태에 오래 머물게 될 것이다. 즉 먼저 CPU를 할당한다.
이후 대기상태에 다다른, 그때서야 CPU 집중 프로세스에 집중적으로 CPU를 할당하면 되는 것이다.
이때 우선순위는 PCB 에 적곤 한다.

- 스케줄링 큐
PCB에 우선순위가 있다고는 하지만, 오로지 우선순위만을 찾기 위하여, 운영체제가 매번 모든 프로세스를 조사하여 우선순위가 높은 프로세스를 찾는 것은 비효율 적이다.
그렇기에 다른 추가 큐칙을 말하기를, 이를 스케쥴링 큐라고 한다.
운영체제가 관리하는 큐는 여러가지로, 대표적으로 준비 큐와 대기 큐가 있다.
각각 CPU를 이용하고 싶은 프로세스들이 서는 줄, 입출력장치를 이용하기 위해 대기상태에 접어든 프로세스들이 서는 줄을 의미해도 된다.
‘큐’의 특징에 맞춰서 선입선출의 규칙을 따르긴 하되, ‘우선순위’ 규칙도 있기에, 어떤 프로세스가 먼저 큐에 삽입되었다고 하더라도, 우선순위가 높은 프로세스가, 그 프로세스보다 먼저 처리될 수도 있다.

그러면 이렇게 되게 된다. 이전에 배웠었던 프로세스 상태 다이어그램과 연관 지어서 다시 정리해보자.
시작과 끝은 각각 생성상태/종료상태 로 된다. 생성상태 이후, 프로세스는 CPU를 사용하기 위하여 대기하는 준비상태가 된다. 이때 준비 큐에 프로세스가 들어간다.
자신의 차례가 되어, 디스패치로 CPU를 사용하고 있는 실행상태가 된다. 이후 만약, 할당 시간이 끝나는 타이머 인터럽트가 일어나면 준비큐로 간다.
다른 방향으로, 실행상태에서, 입출력장치의 작업이 끝날때까지 기다려야 하는 상황이 왔다면, 대기 상태가 된다. 동시에 그 프로세스는 대기큐에 넣어진다.
대기 큐에 있던 프로세스에 대하여, 입출력장치가 완료신호를 보냈다면, 준비상태로 다시 돌아오거니와, 준비큐에 다시 삽입되어져, 자신의 차례를 기다린다.

- 선점형과 비선점형 스케줄링
선점형은 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도, 운영체제가 프로세스로부터, 자원을 강제로 뺏을 수 있으며, 다른 프로세스에게 할당할 수 있는 방식이다.
즉 프로세스의 자원 독점이 불가능하다. 
그동안 사실상 서술하였던, ‘타이머 인터럽트’ 에 의해 다시 프로세스가 준비상태로 돌아오는 것또한 선점형 스케줄링으로 봐도 된다.
이렇게 되면, 프로세스의 자원분배가 골고루 되지만, 단점은 문맥 교환의 횟수가 그만큼 많아지기에 오버헤드가 발생할 수 있다.

반면에 비선점형은 반대이다.
하나의 프로세스가 자원을 사용하고 있다면, 이 프로세스가 종료되거나 스스로 대기상태가 되지 않는 이상, 아무도 끼어들 수 있다.
즉 독점이 가능하다. 장단점도 반대이다. 오버헤드는 적은 반면, 모든 프로세스가 골고루 자원을 사용할 수 없다.




2. CPU 스케줄링 알고리즘
모든 알고리즘에 대해서 외울 필요는 없다. 복습시에도 명심하자. 어차피 스케줄링의 알고리즘에는 아래의 서술할 7가지 방법 이외에 더 많다.

1) 선입 선처리 스케줄링 FCFS
단순히 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다. 어떻게 보면, ‘우선순위’ 라는 것은 신경 안쓰고, 자료구조에서의 큐 특징 (선입선출)만을 적용한 것이라 봐도 된다.
하지만, 이 방법은 프로세스들이 기다리는 시간이 매우 길어질 뿐더러, 다른 프로세스과는 다르게, 실행시간이 매우 적지만, 오로지, 준비큐에 뒤늦게 들어갔다는 이유로, 많은 시간을 기다려야 하는 ‘호위 효과’ 가 일어나기도 한다.

2) 최단 작업 우선 스케줄링 SJF
호위효과를 해결하기 위해 나온 알고리즘이다. 간단하다. CPU사용시간이 짧은 간단한 프로세스를 먼저 실행하게, 긴 프로세스는 나중에 실행하게 하면 된다.

3) 라운드 로빈 스케줄링
‘타임 슬라이스’ 라는 개념이 생겨난다. 타임 슬라이스는 각 프로세스가 CPU를 사용할 수 있는 정해진 시간을 의미한다.
즉 정해진 타임 슬라이스만큼의 시간동안 돌아가며 CPU를 이용하는 선점형 스케쥴링이다. 
그동안 말했었던, 프로세스의 상태 변화 과정에서 타이머 인터럽트가 나타나는 시간이라 봐도 된다.
큐에 삽입된 프로세스들은 삽입순서대로 CPU를 이용하되, 정해진 시간만큼만 CPU를 이용하며, 정해진 시간을 모두 사용했음에도 아직 프로세스가 완료되지 않았다면, 다시 큐의 맨 뒤에 삽입하게 한다.
제일 중요한 것은 타임 슬라이스 크기이다. 지나치게 크면 선입 선처리 스케줄링과 다를 바 없어 호위 효과가 생길 것이다.
또 너무 지나치게 짧다면 이번엔 문맥교환의 비용이 너무 커질 것이다.

4) 최소 잔여 시간 우선 스케줄링 SRT
최단 작업 우선 스케줄링과 라운드 로빈 스케줄링을 섞은 느낌이라 생각해도 된다.
최소 잔여 시간 우선 스케줄링 하에서, 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스도 남아있는 작업 시간이 가장 적은 프로세스가 선택된다.

5) 우선순위 스케줄링
프로세스들에 우선순위를 부여하고, 가장 높은 우선순위를 가진 프로세스 부터 실행하는 스케줄링 알고리즘이다.
어떻게 본다면 최단 작업 우선과, 최소 잔여시간 우선 스케줄링은, 우선순위 스케줄링의 일종으로 볼 수 있다.
그러나 문제점이 있다. 우선순위가 높은 프로세스를 우선적으로 말 그대로 처리하는 것이기에, 큐에 먼저 삽입이 된 상황이더라도, 계속하여, 우선순위가 높은 프로세스들이 요청하면 계속 이 프로세스들은 연기되는 것이다.
이를 ‘기아’ 현상이라 한다. 
이런 형상을 막기 위하여, ‘에이징’ 기법이 있으며, 오랫동안 대기한 프로세스의 우선순위를 대기시간에 따라 우선순위를 계속 높여주는 기법이다,

6) 다단계 큐 스케줄링
우선순위 스케줄링의  발전된 형태이다. 우선순위를 따르되, 우선순위별로 준비 큐를 여러개 사용하는 방식이다.
이렇게 되면, 우선순위가 가장 높은 큐에 있는 프로세스들을 먼저 처리하고, 우선순위가 0인 큐가 비어 있으면, 다음은 1인 큐에 있는 프로세스들을 처리하는 식으로 된다.
장점은 프로세스 유형별로 우선순위를 구분하여 실행할 수 있으며, 또 큐별로 타임 슬라이스를 다르게 제각기 지정할 수도 있으며, 큐 별로 다른 스케줄링 알고리즘을 추가로 사용할 수 있다.
어느 큐는 선입 선처리, 어느 큐에서는 라운드 로빈 스케쥴링 처럼 말이다.
하지만, ‘기아’ 현상이 마찬가지로 문제이다.

7) 다단계 피드백 큐 스케줄링
다단계 큐 스케줄링은 프로세스들이 우선순위 큐사이를 이동할 수 없기에, 기아현상이 나타난다.
이를 막기 위하여, 큐 사이를 프로세스들이 이동할 수 있게 하는 알고리즘이 다단계 피드백 큐 스케줄링이다.
예를 들어보자. 새롭게 생성된 프로세스가 있다. 그럼 우선순위 큐 0에 들어간다. 그리고 자신의 차례가 오면, 실행된다.
만약 타임슬라이스가 지나고도, 실행이 해당 큐에서 끝나지 않았다면, 그 다음으로 우선순위를 낮춰서 우선순위 큐 1에 들어가게 하는 것이다.

반대로 ‘에이징’을 쓰여, 우선순위가 낮으나, 너무 오래 기다리고 있는 프로세스가 있다면, 예컨대, 우선순위 2 큐에 있던 프로세스를 우선순위 1 큐로 들어가게 해준다.
이 방식은 구현하기에 매우 복잡하지만 장점이 크다. CPU 집중 프로세스들은 자연히 우선순위가 점차 낮아지는 반면에,  입출력 집중 프로세스들은 자연스래 우선순위가 높은 큐에서 이미 끝나거나,
조금씩 에이징을 통해 올라오게 되어, 빠르게 끝난다.

