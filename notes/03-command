고급언어와 저급언어: 
컴퓨터는 C, C++, Python과 같은 프로그래밍 언어를 이해할 수 없다. 즉 사람이 이해하고 작성하기 쉽게 만들어진 언어이다. 이러한 언어를 고급 언어라고 한다.
반면에 컴퓨터가 직접 이해 및 실행할 수 있는 언어를 저급 언어라고 한다. 저급 언어는 명령어로 이우어져 있다.
따라서 고급언어로 작성된 소스코드에 대해서 저급언어로 변환되어야 하는 처리를 해야한다. 
저급언어에는 두 가지이 있으며 기계어와 어셈블리어이다.
기계어: 0과 1의 명령어 비트로 이루어진 언어.
어셈블리어:  기계어를 읽기 편한 형태로 변환시킨 언어.

고급언어가 저급언어로 변환되어지는 방법에는 두가지가 있다. 컴파일 방식과 인터프리트 방식이다.
컴파일 언어: 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어이다. 대표적인 컴파일 언어로는 C가 있다. 
고급언어의 소스코드를 저급언어(목적 코드)로 변환 시켜주는 과정을 컴파일이라 하고, 이를 하게 해주는 컴파일러라고 한다.

인터프리터 언어: 인터프리터에 의해 소스 코드가 한 줄씩 실행되는 고급 언어이다. 대표적인 인터프리터 언어는 Python이다.
소스 코드 전체가 저급 언어로 변환되는 것과는 다르게, 한줄씩 차례로 실행하기에, 소스 코드 내에서 오류가 있다면, 컴파일러 언어는 실행 자체가 되지 않으나, 인터프리터는 n번째 줄이 오류가 났다면 n-1번쨰 줄까지는 정상적으로 실행된다.
속도는 컴파일 언어가 더 빠르다.
하지만 예를 들어서 Java의 경우는 인터프리트, 컴파일을 동시에 수행하며, Python도 컴파일 방법을 쓰는 때가 있는 등, 어느 하나의 프로그래밍 언어가, 무조건 컴파일 방법/인터프리트 방법 중 하나만 쓰는 것을 인지하자.

명령어의 구조:
명령어는 연산코드와 오퍼랜드로 구성되어있다. 명령어가 수행할 연산을 연산코드라 하고, 연산에 사용할 데이터 혹은 그 데이터의 위치를 오퍼랜드라고 한다. 각각 연산자, 피연산라고도 불러도 된다.
이 둘에 대하여 연산 코드가 담기는 영역을 연산 코드 필드라 하고, 오퍼랜드가 담기는 영역을 오퍼랜드 필드라고 한다. 이는 저급언어에서 필드끼리 분리되어 있음을 볼 수 있다.

오퍼랜드: 숫자 혹은 문자를 나타네는 데이터 혹은 메모리나 레지스터 주소가 올 수 있다. 
이때 오퍼랜드 필드에는 데이터를 직접 쓰는 것이 아닌, 저장된 위치의 메모리 주소나 레지스터 이름을 쓴다. 이러한 성질 때문에 오퍼랜드 필드를 주소 필드라고도 부른다.
오퍼랜드는 그 개수에 따라서 0-주소, 1-주소 등으로도 불리운다.

연산코드:
연산코드에는 데이터 전송, 산술/논리 연산, 제어 흐름 변경, 입출력 제어 로 크게 4가지로 나눠질 수 있다.
1) 데이터 전송
MOVE: 데이터를 옮겨라 / STORE: 메모리에 저장하라 /LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라. /PUSH/POP (스택 함수와 뜻이 같다)
2) 산술 논리 연산
ADD, SUBTRACT/ MULTIPLY/ DIVIDE
INCREMENT/DECREMENT: 오퍼랜드에 1을 더하라/빼라
AND/OR/ NOT
COMPARE: 두 개의 숫자 또는 TRUE/FLALSE 값을 비교하라.
3) 제어 흐름 변경
JUMP: 특정 주소로 실행 순서를 옮겨라
CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라.
HALT: 프로그램의 실행을 멈춰러
CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라.
4) 입출력 제어
READ/ WRITE: 특정 입출력 장치로부터(로) 데이터를 읽어라 (써라)
START IO / TEST IO : 입출력 장치를 시작하라 / 입출력 장치의 상태를 확인하라

주소지정방식: 오퍼랜드 필드에 데이터를 쓰는 것이 아니라 왜 주소를 담는 것인가..?
명령어의 길이 때문이다. 하나의 명령어가 n비트로 구성되어 있고, 연산코드 필드는 m비트라고 가정하자. 그러면 오퍼랜드 필드에는 (1-주소 명령어 가정) n-m 비트만큼을 넣을 수 있을 것이다. 만약 2-, 3- 주소 명령어라면 더욱 오퍼랜드 필드 크기가 작앋진다.
예를 더 들어 보자. 명령어의 크기가 16비트, 연산 코드 필드가 4비트인 2-주소 명령에서는 오퍼랜드 필드 하나당 고작 6비트 정도 밖에 남지 않는다.  즉 이로 표현할 수 있는 조건의 가짓수는 2^6개이다.
하지만 주소를 넣는다고 생가개보자. 그리고 한 주소에 16비트를 저장할 수 있는 메모리가 있는것이다. 그렇다면 메모리 안의 표현할 수 있는 정보의 가짓수가 2^24 으로 늘어난다.
이는 레지스터 이름을 명시할 때도 마찬가지다. 그 레지스터의 저장 공간만큼 커지게 된다. 이런식으로 연산 코드에 사용할 데이터가 저장된 위치를 유효주소라고 한다.
오퍼랜드 필드에 데이터가 저장된 위치를 명시할때, 연산에 사용할 데이터 위치를 찾는 방법을 주소지정방식 이라고 한다. 이러한 주소지정방식은 5가지 방법이 있다.
1) 즉시 주소 지정 방식:
연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식. 앞에서 말했듯이 데이터의 크기가 매우 작아지는 단점이 있으나, 주소나, 레지스터로부터 찾는 과정이 없기에 빠르다.
ADD R1, #5 이런식으로 된다고 쳤을때 그냥 5가 진짜 데이터인 셈이다.
2) 직접 주소 지정 방식:
오퍼랜드 필드에 유효주소를 직접적으로 명시하는 방식. 이때 유효 주소는 연산의 대상이 되는 데이터가 저장된 위치이다.
ADD R1, [1000] 이런식으로 되어있다면 메모리 1000번지에 데이터가 있음을 말하는 것이다. 즉 주소 1000번지로 가서, 그 번지의 값을 가져와 연산한다.
3) 간접 주소 지정 방식:
유효주소의 주소를 오퍼랜드 필드에 명시한다. 이렇게 된다면 직접 주소 지정 방식보다, 표현할 수 있는 유효주소의 범위가 더 넓어진다.
C언어로 보자. 어떤 값 10을 저장한 a 변수가 있고  a의 주소를 저장한 포인터를 ptr이라고 하자 ptr에 접근하면 주소가 있고, 그 주소로 a로 간다. 이것은 간접 주소 지정 방식과 유사하다.
4) 레지스터 주소 지정 방식: 직접 주소지정방식과 비슷하게, 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 것이다. 일반적으로 CPU외부에 있는 메모리에 접근하는 것보다, CPU 내부에 있는 레지스터에 접근 하는 것이 더 빠르다. 
5)레지스터 간접 주소 지정 방식: 연산에 사용할 데이터를 메모리에 저장하고, 그 주소를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법이다. 간접 주소 지정방식과 비슷하지만 메모리에 접근하는 횟수가 한 번으로 줄어드는장점이 있다.



