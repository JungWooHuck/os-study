1. 동기화
동시다발적으로 실행되는 프로세스들에 대하여 서로 협력하여 실행되는 프로세스들이 있다. 이때 이 프로세스들의 실행 순서와 자원의 일관성을 보장해야 하기에, 반드시 동기화 되어야 한다.
프로세스 동기화란, 즉 프로세스들 사이의 수행 시기를 맞추는 것이다. 크게 두가지 이다.
1) 실행 순서 제어: 프로세스를 올바른 순서대로 실행하기
2) 상호 배제: 동시에 접근해서는 안되는 자원에 하나의 프로세스만 접근하게 하기.

예를 들어보자. Writer과 Reader이라는 프로세스가 두 가지가 있다. Writer프로세스는 Book.txt 파일에 값을 저장하는 프로세스고, Reader 프로세스는 Book.txt  파일을의 저장된 내용을 읽는 프로세스다.
이럴 경우에라면 의도대로, Writer 프로세스 그리고 Reader 이런 순서대로 프로세스가 실행되어야 한다. 
이렇게 올바른 순서대로 실행하게 하는 것이 ‘실행 순서 제어’ 이다.

이제 상호 배제에 대한 예시도 봐보자. 프로세스 A와 B는 모두 계좌의 잔액을 읽고, 잔액에 2/5만원을 더하고, 더한값을 저장하는 프로세스라고 치자. 이때 프로세스 A와 B가 동시에 실행되었다고 가정하자.
초기 현재 잔액이 10만원이었다면 의도대로라면 17만원이 나와야 할것이다. 그러나, 동기화가 이루어 지지 않는 상황에서
프로세스 A가 읽어들인 값에서 2만원을 더한다는 내용을 실행하게 된 뒤에, 만약 이후 문맥 교환이 이루어지고, 프로세스 B가 동시에 실행되어, 잔액을 읽어들이게 된다면, 프로세스 B도 10만원을 대상으로 더해질 것이다.
즉 최종 잔액이 15만원과 같이 엉뚱한 결과가 나올 수 있는 것이다. 이를 위해 상호배제를 위한 동기화가 있는 것이다.
//의문점: 문맥교환이 일어나는 것은 타이머 인터럽트가 발생하였을때 아니한가..? 만약 상호배제를 위한 동기화를 적용한다면 타이머 인터럽트가 일어나더라도 무시하고 프로세스를 끝까지 실행하게끔 하는 것인가? 위의 예시에 따르면 그게 맞는거 같은데..;;//

//답: 문맥 교환은 타이머 인터럽트, I/O 인터럽트 등으로 언제든지 발생이 가능하다. 기억하자. "상호배제는 '문맥 교환 자체'를 막는 것이 아니다."
//딱 다른 프로세스가 임계 구역에 들어오는 것만 막는다.

//추가 의문점: 문맥교환은, 프로세스 A가 실행되는 도중이였다면, CPU가 프로세스 B의 정보로 바꾸는, 즉 실행 주체로 바꾸는 것이 아닌가..?
//그렇게 실행주체가 바뀐 상태였다고 치자. 그럼  아래 <79>번째 줄의 예시에 따르면, 총합++; 과 총합--:을 하였을때, 임계 구역에 프로세스가 하나씩 들어오게 되는 조건을 만족하더라도 꼬이는 것 아닌가?
//어찌 되었든 저급언어 코드들이 실행되는 도중에 문맥교환이 일어나는 것이기에..?

//추가 답: 맞다. 그러니 임계 구역이라는 개념이 있는 것이다. 우선 기억하자. 임계 구역은 '한 줄 짜리 코드' 줄이 아닌, 논리적으로 하나의 작업으로 취급되어야 하는 코드 묶음이다.
//즉 r1 = sum; r1 = r1 + 1; sum = r1; 이것은 '하나의 임계 구역' 논리적 단위가 되는 것이다.
//일단 다시 이거부터 생각하자. 임계 구역은 '그 동안의 문맥교환이 안일어난다' 이게 아니다. '그 동안 다른 실행 주체가 같은 임계 구역에 못 들어온다' 이게 맞는 것이다.

/*
lock();
r1 = sum;
r1 = r1 + 1;
sum = r1;
unlock();
   이렇게 되어있다고 하자. 이게 하나의 임계 구역인 셈이다.
그럼 실제 CPU는 이런식으로 실행된다. 이때 제대로 하기 위해, 저 저급언어 실행도중 타이머 인터럽트가 발생했다고 가정해보자.
A프로세스 시작, lock을 획득 -> r1 = sum -> 타이머 인터럽트 발생 -> OS는 문맥교환시킴 -> B 프로세스 실행시작 -> lock 시도, but, 프로세스 A가 쥐고 있으므로 실패함 = 대기 상태가 됨 
-> OS가 다시 문맥 교환시킴 -> r=r1+1 , sum = r1 실행됨 -> unlock() 실행 -> 그제서야 다시 문맥교환이 되어 B가 될때, 프로세스 시작 가능.

즉 A가 임계구역에 들어간 순간, B는 lock에 의해 접근이 불가능하며, sum이라는 공유 자원을 쓸 수 없게 된다.
*/
다른 대표적인 예시도 있다. 생산자와 소비자 문제이다. 생산자와 소비자는 ‘총합’이라는 데이터를 공유하고 있으며, 생산자는 버퍼에 물건을 넣은 후 물건의 총합에 해당하는 변수를 1 증가시킨다.
반면 소비자는 버퍼에 물건을 빼낸 후 물건의 총합에 해당하는 변수를 1감소 시키는 것이다.
이 상태에서 생산자를 100000번, 소비자도 100000번 함수를 동시에 실행한다고 치자. 초기 합계가 10이라면, 똑같이 실행 이후 합계도 10이어야 한다. 그러나 동기화가 되지 않을 경우 그러지 않다.

코드를 봐보자.
#include <iostream>
#include <queue>
#include <thread>
void produce(); //생산자 스레드
void consume(); //소비자 스레드 (프로세스 뿐만 아니라, 스레드 또한 동기화의 대상이다. 사실상 실행의 흐름을 갖는 모든 것이 동기화의 대상이다.)
//std::queue<int> q;
int sum = 0; //초기합계. 두 스레드가 같이 사용하는 변수, 후에 말하겠지만, 임계구역이 발생하는 대상이다.
int main() {
    std::cout << "초기 합계: " <<  sum << std::endl;
    std::thread producer(produce);  //새로운 스레드 생성됨. produce() 함수 독립적 실행 역할
    std::thread consumer(consume); // 마찬가지로 consume() 실행 역할

    producer.join(); //두 스레드가 끝날 때 까지 대기.
    consumer.join();
    
    std::cout << "producer, consumer 스레드 실행 이후 합계: " <<  sum << std::endl; 
    return 0;
}
void produce() {
    for(int i = 0; i < 100000; i++) {
        // q.push(1);
        sum++;
    }  //계속 1씩 더함
}

void consume() {
    for(int i = 0; i < 100000; i++) {
        // q.pop();
        sum--;
    } //계속 1씩 뺌
}

의도대로라면 0이 나와야 한다. 그러나 초기 합계: 0
/* producer, consumer 스레드 실행 이후 합계: 70214 */ 이렇게 출력이 나온다.
이는 생산자 프로세스와 소비자 프로세스가 제대로 동기화 되지 않았기 때문에 생긴 문제이다. 생산자와 소비자 모두 '총합' 이라는 변수를 동시에 사용하지만, 
소비자가 생산자의 작업이 끝나기도 전에 총합을 수정하고, 생산자도 소비자의 작업이 끝나기도 전에 총합을 수정하는 등의 일이 계속 일어나기 때문이다.


- 공유자원과 임계 구역
코드 중간 주석에 이들의 단어를 쓴적이 있다. 우선 아주 쉽게 말하면 저기에서는 '총합' 이 공유자원 이다. 즉 동시에 실행되는 프로세스들이 공유하는 자원이다.
공유자원은 전역변수, 파일, 입출력, 보조기억장치 등이 될수 있다.

그리고 이 공유 자원 중에서, 두 개이상의 프로세스를 동시에 실행하면 문제가 발생하는 자원이 있기를, 
그러한 자원에 접근하는 코드 영역을 '임계 구역' 이라고 한다.
//의문점: 공유자원이더라도 두 개이상의 프로세스가 동시에 실행됨에도 불구하고 문제가 안생기는 자원이 있는가? 있다면 어떻게 판별하는가..?

임계 구역은 아까 말햇다시피 두 개 이상의 프로세스가 동시에 실행되면 안되는 영역이지만, 잘못된 실행으로 인해, 여러 프로세스가 동시 다발적으로 임계구역의 코드를 실행하여 문제를 일으키는 경우가 있다.
이를 '레이스 컨디션' 이라고 한다.

'레이스 컨디션이 발생하는 근본적인 이유' 는 사실 '고급언어 -> 저급언어' 변환 과정에서 생겨나는 걸로 봐도 된다.
다시 예를 들어보자.  총합 변수를 하나 증가 혹은 하나 감소 시키는 코드는 총합++; 혹은 총합--; 일것이다. 그러나 저급 언어로 변환되면,
r1 = 총합; r1 = r1+1; 총합=r1; 이런식으로 될것이다. 자 다시 과정을 봐보자.
r1 = 총합 -> r1 = r1+1 -> 이러던 도중 문맥 교환됨 -> r2 = 총합 -> r2=r2-1 -> 또 문맥 교환됨 -> 총합 =r1 -> 총합 = r2 이렇게 된다고 치자. 
초기 총합이 10이였다면 최종총합은 의도대로 10이 나오는 것이 아닌 9가 나오게 된다.

상호 배제를 위한 동기화는 이와 같은 일이 발생하지 않도록 두 개 이상의 프로세스가 임계 구역에 동시에 접근하지 못하도록 관리하는 것이다.
운영체제는 이 문제에 대해, 3가지 원칙을 지킨다.
1) 상호배제: 한 프로세스가 임계 구역에 진입했다면 다른 프로세스는 임계 구역에 들어올 수 없다.
2) 진행: 임계 구역에 어떤 프로세스도 진입하지 않았다면, 임계 구역에 진입하고자 하는 프로세스는 들어갈 수 있어야 한다.
3) 유한 대기: 한 프로세스가 임계 구역에 진입하고 싶다면, 반드시 언젠가는 임계구역에 들어올 수 있어야 한다.
